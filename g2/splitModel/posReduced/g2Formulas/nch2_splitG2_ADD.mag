///////////////////////////////////////////////////////////////////////////////
// Author: Sebastian Lindner, 2019                                                        
//                                                   
// Description: Genus 2 divisor addition formulas for the 4 coordinate Mumford         
//              representation in reduced basis over not characteristic 2 or 3
//              fields where:              
//              h(x) = 0 and             
//              f(x) = f6*x^6  + f4x^4 + f3x^3 + f2x^2 + f1x + f0           
//                                                                      
///////////////////////////////////////////////////////////////////////////////

//Must keep next two lines in this format for latex conversion
//Constant: f6,f5,f4,f3,f2,f1,f0,h3,h2,h1,h0,y3,y2,y1,y0,d9,d8,d7,d6,d5,d4,d3,d2,d1,d0,c5,c4,c3,c2,c1,c0

///////////////////////////////////////////////////////////////////////////////
// Deg01ADDDWN():         
// Input:     u0,v0: Mumford coordinates for divisor D=<x + u0,v0,1> in  
//                   reduced basis.
// Implicitly 1,0,2: Mumford coordinates for divisor D=<1,0,2> in reduced 
//                   basis.       
//              ccs: Table of curve constants and precomputations, see 
//                   Precompuation in nch23_splitG2_UTL.mag 
//      
// Output: Mumford coordinates up1,up0,vp1,vp0 and balance weight np for 
//         for reduceed and balanced Dp ~ D.               
// Description: Explicit computation for adding <1,0,2> and degree 1 divisor.          
///////////////////////////////////////////////////////////////////////////////
Deg01ADDDWN:= function(u0,v0,ccs)   
    /* //startIGNORE
    //Poly Dev Testing
    FF:=Parent(u0);
    R<x>:=PolynomialRing(FF);
    f := R!ccs[1];
    h := R!ccs[2];
    V := R!ccs[3];
    u := x + u0;
    v := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + Coeff(V,1)*x + v0;

    //Formulation
    upp := ExactQuotient(f - v*(v +  h),u);
    upp := upp/LeadingCoefficient(upp);                 
    vpp := V - (v + h + V) mod upp;
    
    return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),0; 
    */ //endIGNORE
    
    y0:= ccs[2][1]; 
    y1:= ccs[2][2]; 
    d1:= ccs[2][3];
    d2:= ccs[2][4];
    d3:= ccs[2][5];
    f1:= ccs[1][2]; 
    f4:= ccs[1][5];  

    //z = (f - h*v - v^2)/c3   
    z0 := y0 - v0;
    //z1 := d1;

    if IsZero(z0) then  
        if IsZero(d1) then

            if ADD_DEBUG then "ADD00"; end if;
            return 0,0,1,y1,y0,0;
        end if;//d1

        w2  := d1^-1;
        up0 := w2*(f1 - v0*f4) - u0;
        t1  := up0^2;
        vp0 := up0*(f4 + t1 + t1) - v0;

        if ADD_DEBUG then "ADD01"; end if;
        return 0,1,up0,y1,vp0,0;
    end if;//z0

    //up := ExactQuotient (z,u);
    //up := up / LeadingCoefficient(up);
    w2  := z0^-1;
    up1 := w2*d2 - u0;
    up0 := w2*(d3 - v0*y1) - u0*up1;

    //vp := Vpl - (Vpl + v + h) mod up;
    t0  := up0 - up1^2;
    t1  := up1 + up1;   
    vp1 := t0 + t0 - y1;
    vp0 := -up0*t1 - v0;

    if ADD_DEBUG then "ADD02"; end if;
    return 1,up1,up0,vp1,vp0,0;
end function;


///////////////////////////////////////////////////////////////////////////////
// Deg01ADDUP():         
// Input:     u0,v0: Mumford coordinates for divisor D=<x + u0,v0,0> in  
//                   reduced basis.
// Implicitly 1,0,0: Mumford coordinates for divisor D=<1,0,0> in reduced 
//                   basis.       
//              ccs: Table of curve constants and precomputations, see 
//                   Precompuation in nch23_splitG2_UTL.mag 
//      
// Output: Mumford coordinates up1,up0,vp1,vp0 and balance weight np for 
//         for reduceed and balanced Dp ~ D.               
// Description: Explicit computation for adding <1,0,0> and degree 1 divisor.       
///////////////////////////////////////////////////////////////////////////////
Deg01ADDUP:= function(u0,v0,ccs)
    /*//startIGNORE
    //Poly Dev Testing
    FF:=Parent(u0);
    R<x>:=PolynomialRing(FF);
    f := R!ccs[1];
    h := R!ccs[2];
    V := R!ccs[3];
    u := x + u0;
    v := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + Coeff(V,1)*x + v0;

    //Formulation
    v := -V-h - ((-V-h - v) mod u);
    upp := ExactQuotient(f - v*(v +  h),u);
    upp := upp/LeadingCoefficient(upp);                 
    vpp := V - (v + h + V) mod upp;
    npp := 2- Degree(upp);
    
    return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),npp; 
    */ //endIGNORE

    y0:= ccs[2][1]; 
    y1:= ccs[2][2]; 
    d1:= ccs[2][3];
    d2:= ccs[2][4];
    d3:= ccs[2][5];  
    f1:= ccs[1][2]; 
    f4:= ccs[1][5];
      

    //v:= -V-h - ((-V-h - v) mod u); 
    //vp:= -v     
    t0  := u0^2;                            
    vp0 := u0*(f4 + t0 + t0) - v0;

    //up := ExactQuotient (f - h*vp - vp^2,u);
    //up := up / LeadingCoefficient(up);
    //z1 := d1;
    z0 := y0 - vp0;

    if IsZero(z0) then 
        if IsZero(d1) then
            
            if ADD_DEBUG then "ADD03"; end if;
            return 0,0,1,y1,y0,2;
        end if;//d1

        w2  := d1^-1;
        up0 := w2*(f1 - vp0*f4) - u0;

        if ADD_DEBUG then "ADD04"; end if;
        return 0,1,up0,y1,vp0,1;
    end if;//z0

    w2  := z0^-1;
    up1 := w2*d2 - u0;
    up0 := w2*(d3 - vp0*y1) - u0*up1;

    if ADD_DEBUG then "ADD05"; end if;
    return 1,up1,up0,y1,vp0,0;
end function;


///////////////////////////////////////////////////////////////////////////////
// Deg02ADDDWN():         
// Input: u1,u0,v1,v0: Mumford coordinates for divisor   
//                     D=<x^2 + u1x + u0, v1x + v0, 0> in reduced basis.
//   Implicitly 1,0,2: Mumford coordinates for divisor D=<1,0,2> in reduced 
//                     basis.       
//                ccs: Table of curve constants and precomputations, see 
//                     Precompuation in nch23_splitG2_UTL.mag 
//      
// Output: Mumford coordinates up1,up0,vp1,vp0 and balance weight np for 
//         for reduceed and balanced Dp ~ D.               
// Description: Explicit computation for adding <1,0,2> and degree 2 divisor.          
///////////////////////////////////////////////////////////////////////////////
Deg02ADDDWN:= function(u0,u1,v0,v1,ccs)
    /* //startIGNORE
    //Poly Dev Testing
    FF:=Parent(u0);
    R<x>:=PolynomialRing(FF);
    f := R!ccs[1];
    h := R!ccs[2];
    V := R!ccs[3];
    u := x^2 + u1*x + u0;
    v := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + v1*x + v0;

    //Formulation
    upp := ExactQuotient(f - v*(v +  h),u);
    upp := upp/LeadingCoefficient(upp);                 
    vpp := V - (v + h + V) mod upp;
    
    return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),0; 
    */ //endIGNORE
    
    y0:= ccs[2][1]; 
    y1:= ccs[2][2];
    f2:= ccs[1][3]; 
    f4:= ccs[1][5];
    d4:= ccs[2][6];

    //z = (f - h*v - v^2)/c3
    z0 := y0 - v0;
    z1 := y1 - v1;
    
    if IsZero(z1) then  
        if IsZero(z0) then
            
            if ADD_DEBUG then "ADD06"; end if;
            return 0,0,1,y1,y0,0;
        end if;//z0

        w2  := z0^-1;
        up0 := w2*(d4 - (v1^2)/2) - u1;
        t0  := up0^2;
        vp0 := up0*(f4 + t0 + t0) - v0;

        if ADD_DEBUG then "ADD07"; end if;
        return 0,1,up0,y1,vp0,0;
    end if;//z1

    //up := ExactQuotient (z,u);
    //up := up / LeadingCoefficient(up);
    w2  := z1^-1;
    up1 := w2*z0 - u1;
    up0 := w2*(d4 - (v1^2)/2) - u0 - u1*up1;

    //vp := Vpl - (Vpl + v + h) mod up;
    t0  := up0 - up1^2;
    t1  := up1 + up1;
    vp1 := t0 + t0 - v1;
    vp0 := -v0 - t1*up0;

    if ADD_DEBUG then "ADD08"; end if;
    return 1,up1,up0,vp1,vp0,0;
end function;


///////////////////////////////////////////////////////////////////////////////
// Deg02ADDUP():         
// Input: u1,u0,v1,v0: Mumford coordinates for divisor 
//                     D=<x^2 + u1x + u0, v1x + v0, 0> in reduced basis.
//   Implicitly 1,0,0: Mumford coordinates for divisor D=<1,0,0> in reduced 
//                     basis.       
//                ccs: Table of curve constants and precomputations, see 
//                     Precompuation in arb_splitG2_UTL.mag 
//      
// Output: Mumford coordinates up1,up0,vp1,vp0 and balance weight np for 
//         for reduceed and balanced Dp ~ D.               
// Description: Explicit computation for adding <1,0,0> and degree 2 divisor.          
///////////////////////////////////////////////////////////////////////////////
Deg02ADDUP:= function(u0,u1,v0,v1,ccs)
    /*//startIGNORE
    //Poly Dev Testing
    FF:=Parent(u0);
    R<x>:=PolynomialRing(FF);
    f := R!ccs[1];
    h := R!ccs[2];
    V := R!ccs[3];
    u := x^2 + u1*x + u0;
    v := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + v1*x + v0;

    //Formulation
    v := -V-h - ((-V-h - v) mod u);
    upp := ExactQuotient(f - v*(v +  h),u);
    upp := upp/LeadingCoefficient(upp);                 
    vpp := V - (v + h + V) mod upp;
    npp := 2- Degree(upp);
    
    return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),npp; 
    */ //endIGNORE
    
    y0:= ccs[2][1]; 
    y1:= ccs[2][2]; 
    f2:= ccs[1][3];
    d4:= ccs[2][6];

    //v1 := -V-h - (-V-h - v1) mod u1;
    t1 := u1 + u1;
    t2 := u1^2 - u0;
    v1 := v1 + t2 + t2;
    v0 := v0 + u0*t1; 

    //z = (f - h*v - v^2)/c3
    z0 := v0 + y0;
    z1 := v1 + y1;

    if IsZero(z1) then  
        if IsZero(z0) then

            if ADD_DEBUG then "ADD09"; end if;
            return 0,0,1,y1,y0,2;
        end if;//z0

        w2  := z0^-1;
        up0 := w2*(d4 - (v1^2)/2) - u1;

        if ADD_DEBUG then "ADD10"; end if;
        return 0,1,up0,y1,-v0,1;
    end if;//z1

    //u := ExactQuotient(z,u1);
    //u := u/LeadingCoefficient(u);
    w2  := z1^-1;
    up1 := w2*z0 - u1;
    up0 := w2*(d4 - (v1^2)/2) - u0 - u1*up1;

    //v := V - (v1 + h + V) mod u;
    //vp1 := -v1;
    //vp0 := -v0;

    if ADD_DEBUG then "ADD11"; end if;
    return 1,up1,up0,-v1,-v0,0;
end function;



///////////////////////////////////////////////////////////////////////////////
// Deg1ADD():         
// Input:  u0,v0: Mumford coordinates for divisor D=<x + u0,v0,n> in reduced
//                basis where 0<=n<=1 and n + np = 1
//       up0,vp0: Mumford coordinates for divisor Dp=<x + up0,vp0,np> in reduced
//                basis where 0<=n<=1 and n + np = 1
//           ccs: Table of curve constants and precomputations, see 
//                Precompuation in nch23_splitG2_UTL.mag
//      
// Output: Mumford coordinates upp1,upp0,vpp1,vpp0 and balance weight npp for 
//         for reduceed and balanced Dpp ~ D + Dp.               
// Description: Explicit computation for adding two degree 1 divisors.                 
///////////////////////////////////////////////////////////////////////////////
Deg1ADD:= function(u0,v0,up0,vp0,ccs)
    /* //startIGNORE
    //Poly Dev Testing
    FF:=Parent(u0);
    R<x>:=PolynomialRing(FF);
    f := R!ccs[1];
    h := R!ccs[2];
    V := R!ccs[3];
    u := x + u0;
    v := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + Coeff(V,1)*x + R!v0;
    up := x + up0;
    vp := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + Coeff(V,1)*x + R!vp0;
    Q := quo<R | up>;
    
    //Formulation
    d := u mod up;
    if IsZero(d) then
        dw := (vp + v + h) mod up; 
        if IsZero(dw) then
            return 0,0,1,Coeff(V,1),Coeff(V,0),1;
        end if;
        k := ExactQuotient(f-v*(v + h),u);
        s := k*R!(Q!dw^-1) mod up;
        upp := u^2;
        vpp := V - (V - v - u*s) mod upp;
        return 1,Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),0;
    end if;
    s := (vp - v)*R!(Q!d^-1) mod up;
    upp := u*up;
    vpp := V - (V - v - u*s) mod upp;

    return 1,Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),0;
    */ //endIGNORE
    
    f1:= ccs[1][2]; 
    f2:= ccs[1][3]; 
    f3:= ccs[1][4]; 
    f4:= ccs[1][5]; 
    y0:= ccs[2][1]; 
    y1:= ccs[2][2];
    d1:= ccs[2][3];
    d2:= ccs[2][4];
    d3:= ccs[2][5];

    //d = u mod up
    d := u0 - up0;

    if IsZero(d) then
        //upp := u^2;
        upp1 := u0 + u0;
        upp0 := u0^2;

        //dw := ((v+ vp + h) mod u);
        dw := v0 + vp0 - u0*f4 - upp0*upp1;
        if IsZero(dw) then
            if ADD_DEBUG then "ADD12"; end if;
            return 0,0,1,y1,y0,1;
        end if;//dw

        //k := ExactQuotient(f - v(v - h), u);
        //s0 := k/dw mod u;
        t0 := y0 - v0;
        t2 := f1 - f4*v0 - u0*(d1 + d1 - upp1*(t0 + t0 + t0));
        s0:= t2*dw^-1;
        
        //vpp := V - ((V - s*u - v) mod upp);
        vpp1 := y1 + s0;
        vpp0 := v0 + s0*u0;

        if ADD_DEBUG then "ADD13"; end if;
        return 1,upp1,upp0,vpp1,vpp0,0;
    end if;//d

    //s0 = s0p/d
    s0 := (vp0 - v0)*d^-1;

    //upp = u*up
    upp1 := u0 + up0;
    upp0 := u0*up0;
    
    //vpp = V - (V - vp - up*s) mod upp
    vpp1 := y1 + s0;
    vpp0 := v0 + u0*s0;

    if ADD_DEBUG then "ADD14"; end if;                                              
    return 1, upp1, upp0, vpp1, vpp0, 0;
end function;

///////////////////////////////////////////////////////////////////////////////
// Deg1ADDDWN():         
// Input:  u0,v0: Mumford coordinates for divisor D=<x + u0,v0,1> in reduced
//                basis.
//       up0,vp0: Mumford coordinates for divisor Dp=<x + up0,vp0,1> in reduced
//                basis.
//           ccs: Table of curve constants and precomputations, see 
//                Precompuation in nch23_splitG2_UTL.mag
//      
// Output: Mumford coordinates upp1,upp0,vpp1,vpp0 and balance weight npp for 
//         for reduceed and balanced Dpp ~ D + Dp.               
// Description: Explicit compuation for adding two degree 1 divisors.                 
///////////////////////////////////////////////////////////////////////////////
Deg1ADDDWN:= function(u0,v0,up0,vp0,ccs)
    /* //startIGNORE
    //Poly Dev Testing
    FF:=Parent(u0);
    R<x>:=PolynomialRing(FF);
    f := R!ccs[1];
    h := R!ccs[2];
    V := R!ccs[3];
    u := x + u0;
    v := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + Coeff(V,1)*x + R!v0;
    up := x + up0;
    vp := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + Coeff(V,1)*x + R!vp0;
    Q := quo<R | up>;
    
    //Formulation
    d := u mod up;
    if IsZero(d) then
        return 0,0,1,Coeff(V,1),Coeff(V,0),2;
    end if;
    s := R!(Q!d^-1)*(vp - v) mod up;
    k := ExactQuotient(f-v*(v + h),u);
    upp := ExactQuotient(-s*(u*s + 2*v + h) + k, up); //M1:=ExactQuotient(u1*s-v2+v1,u2); M2:=ExactQuotient(s*(v2+v1+h)-k,u2); u:=-s*M1-M2;
    upp := upp/LeadingCoefficient(upp);
    vpp := V - (V + u*s + v + h) mod upp;

    return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),0;
    */ //endIGNORE
    
    f4:= ccs[1][5];
    y0:= ccs[2][1]; 
    y1:= ccs[2][2]; 
    d2:= ccs[2][4];
   
    //d := u mod up;
    d := u0 - up0;
    if IsZero(d) then
        
        if ADD_DEBUG then "ADD15"; end if;
        return 0,0,1,y1,y0,2;
    end if;//d

    //sp := vp - v
    sp0 := vp0 - v0;

    //k := ExactQuotient(f - v1*h - v1^2, u1);
    //z := k/2
    z0 := y0 - v0;
    //k2 := t0 + t0;
    //z1 := d2 - u0*z0;

    if IsZero(sp0) then
        if IsZero(z0) then
            
            if ADD_DEBUG then "ADD16"; end if;
            return 0,0,1,y1,y0,0;
        end if;//z0

        //upp := ExactQuotient(-k, u);
        //up  := upp/LeadingCoefficient(upp);
        w1   := z0^-1;
        upp0 := w1*(d2 - u0*z0) - up0;
        
        //vp  := V  - (V - v) mod up;
        t1 := upp0^2;
        vpp0 := upp0*(f4 + t1 + t1) - v0;

        if ADD_DEBUG then "ADD17"; end if;
        return 0,1,upp0,y1,vpp0,0;
    end if;//sp0

    //s0 := ((vp - vp)/u) mod up and 1/s0;
    w0 := (sp0*d)^-1; //1/s0*d^2
    w1 := w0*d^2;      //1/s0
    s0 := w0*sp0^2; 

    //upp := ExactQuotient(s*(u1*s + 2*v1 + h) - k, u2);
    //up  := upp/LeadingCoefficient(upp);
    t1   := z0*w1; 
    upp1 := -t1 - up0;
    upp0 := y1 + s0/2 - w1*d2 + u0*t1 - up0*upp1;

    //vp  := V - ((V - (-s*u1 - v1 - h)) mod up);
    t0   := -upp1 - upp1;
    vpp1 := -y1 - s0 + upp0 + upp0 + upp1*t0;
    vpp0 := -v0 - s0*u0 + upp0*t0;
    
        if ADD_DEBUG then "ADD18"; end if;
    return 1,upp1,upp0,vpp1,vpp0,0;
end function;


///////////////////////////////////////////////////////////////////////////////
// Deg1ADDUP():         
// Input:  u0,v0: Mumford coordinates for divisor D=<x + u0,v0,0> in reduced
//                basis.
//       up0,vp0: Mumford coordinates for divisor Dp=<x + up0,vp0,0> in reduced
//                basis.
//           ccs: Table of curve constants and precomputations, see 
//                Precompuation in nch23_splitG2_UTL.mag
//      
// Output: Mumford coordinates upp1,upp0,vpp1,vpp0 and balance weight npp for 
//         for reduceed and balanced Dpp ~ D + Dp.               
// Description: Explicit compuation for adding two degree 1 divisors.                 
///////////////////////////////////////////////////////////////////////////////
Deg1ADDUP:= function(u0,v0,up0,vp0,ccs)
    /* //startIGNORE
    //Poly Dev Testing
    FF:=Parent(u0);
    R<x>:=PolynomialRing(FF);
    f := R!ccs[1];
    h := R!ccs[2];
    V := R!ccs[3];
    u := x + u0;
    v := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + Coeff(V,1)*x + R!v0;
    up := x + up0;
    vp := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + Coeff(V,1)*x + R!vp0;
    Q := quo<R | up>;
    
    //Formulation
    d := u mod up;
    if IsZero(d) then
        return 0,0,1,Coeff(V,1),Coeff(V,0),0;
    end if;
    v := -V-h - (-V-h - v) mod u;
    s := R!(Q!d^-1)*(vp - v) mod up;
    k := ExactQuotient(f-v*(v + h),u);
    upp := ExactQuotient(-s*(u*s + 2*v + h) + k, up); //M1:=ExactQuotient(u1*s-v2+v1,u2); M2:=ExactQuotient(s*(v2+v1+h)-k,u2); u:=-s*M1-M2;
    upp := upp/LeadingCoefficient(upp);
    vpp := V - (V + u*s + v + h) mod upp;
    npp := 2- Degree(upp);

    return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),npp;
    */ //endIGNORE
    
    f4:= ccs[1][5];
    y0:= ccs[2][1]; 
    y1:= ccs[2][2]; 
    d2:= ccs[2][4];

    //d := u1 mod u2;
    d := u0 - up0;
    if IsZero(d) then
        
        if ADD_DEBUG then "ADD19"; end if;
        return 0,0,1,y1,y0,0;
    end if;//d

    //vt := -V - h + ((V + h + v1) mod u1);
    t0  := u0^2;
    vt0 := v0 - u0*(t0 + t0 + f4);

    //sp := (vp - vt) mod up
    t1  := up0^2;
    sp0 := vp0 - vt0 - up0*(t1 + t1 + f4);

    //k := ExactQuotient(f - v1*h - v1^2, u1);
    //z := k/2
    z0 := y0 + vt0;
    //z1 := d2 - u0*z0;   

    if IsZero(sp0) then  
        if IsZero(z0) then
            
            if ADD_DEBUG then "ADD20"; end if;
            return 0,0,1,y1,y0, 2;
        end if;//z0

        //upp := ExactQuotient(-k, up);
        //upp  := upp/LeadingCoefficient(upp);
        w1   := z0^-1;
        upp0 := w1*(d2 - u0*z0) - up0;
        
        //vp  := V - ((V - (-s*u1 - vt - h)) mod up);
        //vpp0 := -vt0;

        if ADD_DEBUG then "ADD21"; end if;
        return 0,1,upp0,y1,-vt0,1;
    end if;//sp0

    //s0 := ((v2 - vt)/u1) mod u2 and 1/s0;
    w0 := (sp0*d)^-1; //1/s0*d^2
    w1 := w0*d^2;      //1/s0
    s0 := w0*sp0^2; 

    //upp  := ExactQuotient(s*(u1*s + 2*vt + h) - k, u2);
    //up  := upp/LeadingCoefficient(upp);
    t0   := z0*w1;
    upp1 := t0 - up0;
    upp0 := y1 - s0/2 + w1*d2 - u0*t0 - up0*upp1;

    //vp  := V - ((V - (-s*u1 - vt - h)) mod up);
    vpp1 := y1 - s0;
    vpp0 := -vt0 - s0*u0;
 
    if ADD_DEBUG then "ADD22"; end if;
    return 1,upp1,upp0,vpp1,vpp0,0;
end function;


///////////////////////////////////////////////////////////////////////////////
// Deg12ADD():         
// Input:     u0,v0: Mumford coordinates for divisor D=<x + u0,v0,1> in 
//                     reduced basis.
//  up0,up1,vp0,vp1: Mumford coordinates for divisor Dp=<x + up0,vp0,0> in 
//                     reduced basis.
//           ccs: Table of curve constants and precomputations, see 
//                Precompuation in nch23_splitG2_UTL.mag
//      
// Output: Mumford coordinates upp1,upp0,vpp1,vpp0 and balance weight npp for 
//         for reduceed and balanced Dpp ~ D + Dp.               
// Description: Explicit computation for adding a degree 1 and degree 2 divisor.                 
///////////////////////////////////////////////////////////////////////////////
Deg12ADD:= function(u0,v0,up0,up1,vp0,vp1,ccs)
    /* //startIGNORE
    //Poly Dev Testing
    FF:=Parent(u0);
    R<x>:=PolynomialRing(FF);
    f := R!ccs[1];
    h := R!ccs[2];
    V := R!ccs[3];
    u := x + u0;
    v := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + Coeff(V,1)*x + v0;
    up := x^2 + up1*x + up0;
    vp := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + vp1*x + vp0;
    Q := quo<R | u>;
    
    //Formulation
    d := up mod u;
    if IsZero(d) then
        dw := (v + vp + h) mod u; 
        if IsZero(dw) then
            upp := ExactQuotient(up,u);
            vpp  := V - (V - vp) mod upp;
            return 0,1,Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),1;
        end if;
        k := ExactQuotient(f - vp*(vp + h),up);
        s  := R!(Q!dw^-1)*k mod u;
        //M1 := ExactQuotient(up*s-v+vp,u); M2:=ExactQuotient(s*(v+vp+h)-k,u); u:=-s*M1-M2;
        upp  := ExactQuotient(-s*(s*up + 2*vp + h) + k, u);
        upp  := upp/LeadingCoefficient(upp);
        vpp  := V - (V + s*up + vp + h) mod upp;
        return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),0;
    end if;
    k := ExactQuotient(f - vp*(vp + h),up);
    s := R!(Q!d^-1)*(v - vp) mod u;
    //M1 := ExactQuotient(up*s-v+vp,u); M2:=ExactQuotient(s*(v+vp+h)-k,u); u:=-s*M1-M2;
    upp  := ExactQuotient(-s*(s*up + 2*vp + h) + k, u);
    upp  := upp/LeadingCoefficient(upp);
    vpp  := V - (V + s*up + vp + h) mod upp;

    return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),0;
    */ //endIGNORE
    
    f0:= ccs[1][1]; 
    f1:= ccs[1][2]; 
    f2:= ccs[1][3];  
    y0:= ccs[2][1]; 
    y1:= ccs[2][2];

    //d := up mod u;
    t0 := u0*up1;
    t1 := u0^2;
    d  := up0 - t0 + t1;
    if IsZero(d) then
        //dw := (v + vp + h) mod u; 
        dw := v0 + vp0 - u0*(vp1 + y1 + t1 + t1);
        if IsZero(dw) then
            //upp := ExactQuotient(up,u);
            upp0 := up1 - u0;
            //vpp  := V - (V - vp) mod upp;
            vpp0 := vp0 + upp0*(y1 - vp1);

            if ADD_DEBUG then "ADD23"; end if;
            return 0,1,upp0,y1,vpp0,1; // 1 = n + np
        end if;//dw

        //k := ExactQuotient(f - vp*(vp + h),up);
        t2 := y1 - vp1;
        t3 := y0 - vp0;
        k2 := t2 + t2;
        k1 := t3 + t3 - up1*k2;
        k0 := f2 - vp1^2 - up0*k2 - up1*k1;

        //s  := R!(Q!dw^-1)*k mod u;
        sp0 := (k0 - u0*(k1 - u0*k2));

        if IsZero(sp0) then
            if IsZero(t2) then
                
                if ADD_DEBUG then "ADD24"; end if;
                return 0,0,1,y1,y0,0;
            end if;//t2

            //upp  := ExactQuotient(k, u);
            //upp  := upp/LeadingCoefficient(upp);
            w2 := t2^-1;
            upp0 := w2*t3 - up1 - u0;

            //vpp  := V - (V + vp + h) mod upp;
            vpp0 := upp0*(y1 + vp1 + upp0*(upp0 + upp0)) - vp0;

            if ADD_DEBUG then "ADD25"; end if;
            return 0,1,upp0,y1,vpp0,0;
        end if;//sp0

        //s0 = sp0/d
        w2 := (sp0*dw)^-1;    //1/s*d^2
        w3 := w2*sp0;        //1/d
        w4 := dw^2*w2;       //1/s
        s0 := w3*sp0;

        //M1 := ExactQuotient(up*s-v+vp,u); M2:=ExactQuotient(s*(v+vp+h)-k,u); u:=-s*M1-M2;
        //upp  := ExactQuotient(-s*(s*up + 2*vp + h) + k, u);
        //upp  := upp/LeadingCoefficient(upp);
        t0 := s0*up1 + vp1;
        upp1 := s0/2 - w4*t2 - u0;
        upp0 := (t0 + vp1)/2 - w4*(y0 - vp0 - t2*up1) - u0*upp1;

        //vpp  := V - (V + s*up + vp + h) mod upp;
        t1   := s0 - upp1 - upp1;
        vpp1 := upp1*t1 + upp0 + upp0 - t0;
        vpp0 := upp0*t1 - s0*up0 - vp0;
        
        if ADD_DEBUG then "ADD26"; end if;
        return 1,upp1,upp0,vpp1,vpp0,0;
    end if;//d

    //k := ExactQuotient(f - vp*(h + vp), up);
    //z := k/c3
    z0 := y1 - vp1;
    //z1 := y0 - vp0 - z0*up1;

    //sp0 := (v - vp) mod u;
    sp0 := v0 - vp0 - z0*u0;

    if IsZero(sp0) then           
        //vp1 == y1, so (f - h*vn - vn^2) is deg 3
        if IsZero(z0) then 
            
            if ADD_DEBUG then "ADD27"; end if; 
            return 0,0,1,y1,y0,0;
        end if;//z0

        w2   := z0^-1;
        upp0 := w2*(y0 - vp0) - up1 - u0;
        t1   := upp0^2;
        vpp0 := upp0*(y1 + vp1 + t1 + t1) - vp0;
        
        if ADD_DEBUG then "ADD28"; end if;
        return 0, 1, upp0, y1, vpp0, 0;
    end if;//sp0

    //s0 = sp0/d;
    w2 := (sp0*d)^-1;    //1/s*d^2
    w3 := w2*sp0;        //1/d
    w4 := d^2*w2;       //1/s
    s0 := w3*sp0;

    //uppp  := ExactQuotient(s*(-s*u1 - 2*v1 - h) + k, u2);
    //upp := u/LeadingCoefficient(u);
    vh1  := s0*up1 + vp1;
    upp1 := s0/2 - w4*z0 - u0;
    upp0 := (vh1 + vp1)/2 - w4*(y0 - vp0 - z0*up1) - u0*upp1;
    
    //vpp:= Vpl - (Vpl+V+h) mod upp;
    t1   := s0 - upp1 - upp1;
    vpp1 := upp0 + upp0 + t1*upp1 - vh1;
    vpp0 := upp0*t1 - s0*up0 - vp0;

    if ADD_DEBUG then "ADD29"; end if;
    return 1, upp1, upp0, vpp1, vpp0, 0;
end function;


///////////////////////////////////////////////////////////////////////////////
// Deg12ADDUP():         
// Input:     u0,v0: Mumford coordinates for divisor D=<x + u0,v0,0> in 
//                     reduced basis.
//  up0,up1,vp0,vp1: Mumford coordinates for divisor Dp=<x + up0,vp0,0> in 
//                     reduced basis.
//           ccs: Table of curve constants and precomputations, see 
//                Precompuation in nch23_splitG2_UTL.mag
//      
// Output: Mumford coordinates upp1,upp0,vpp1,vpp0 and balance weight npp for 
//         for reduceed and balanced Dpp ~ D + Dp.               
// Description: Explicit computation for adding a degree 1 and degree 2 divisor.                 
///////////////////////////////////////////////////////////////////////////////
Deg12ADDUP:= function(u0,v0,up0,up1,vp0,vp1,ccs)
    /* //startIGNORE
    //Poly Dev Testing
    FF:=Parent(u0);
    R<x>:=PolynomialRing(FF);
    f := R!ccs[1];
    h := R!ccs[2];
    V := R!ccs[3];
    u := x + u0;
    v := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + Coeff(V,1)*x + v0;
    up := x^2 + up1*x + up0;
    vp := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + vp1*x + vp0;
    Q := quo<R | u>;
    
    //Formulation
    vp := -V-h - ((-V-h -vp) mod up);
    d := up mod u;
    if IsZero(d) then
        dw := (v + vp + h) mod u; 
        if IsZero(dw) then
            upp := ExactQuotient(up,u);
            vpp  := V - (V - vp) mod upp;
            return 0,1,Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),0;
        end if;
        k := ExactQuotient(f - vp*(vp + h),up);
        s  := R!(Q!dw^-1)*k mod u;
        //M1 := ExactQuotient(up*s-v+vp,u); M2:=ExactQuotient(s*(v+vp+h)-k,u); u:=-s*M1-M2;
        upp  := ExactQuotient(-s*(s*up + 2*vp + h) + k, u);
        upp  := upp/LeadingCoefficient(upp);
        vpp  := V - (V + s*up + vp + h) mod upp;
        return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),2-Degree(upp);
    end if;
    k := ExactQuotient(f - vp*(vp + h),up);
    s := R!(Q!d^-1)*(v - vp) mod u;
    //M1 := ExactQuotient(up*s-v+vp,u); M2:=ExactQuotient(s*(v+vp+h)-k,u); u:=-s*M1-M2;
    upp  := ExactQuotient(-s*(s*up + 2*vp + h) + k, u);
    upp  := upp/LeadingCoefficient(upp);
    vpp  := V - (V + s*up + vp + h) mod upp;

    return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),2-Degree(upp);
    */ //endIGNORE
    
    f0:= ccs[1][1]; 
    f1:= ccs[1][2]; 
    f2:= ccs[1][3]; 
    f3:= ccs[1][4]; 
    y0:= ccs[2][1]; 
    y1:= ccs[2][2];

    //vp := -V-h - ((-V-h -vp) mod up);
    t2  := up1 + up1;
    vp1 := vp1 - up0 - up0 + t2*up1;
    vp0 := vp0 + up0*t2;

    //d := up mod u;
    t0 := u0*up1;
    t1 := u0^2;
    d  := up0 - t0 + t1;

    if IsZero(d) then
        //dw := (v + vp + h) mod u; 
        dw := vp0 + v0 - u0*(y1 + vp1);
        
        if IsZero(dw) then
            //upp := ExactQuotient(up,u);
            upp0 := up1 - u0;
            //vpp  := V - (V - vp) mod upp;
            t0 := upp0^2;
            vpp0 := vp0 + upp0*(y1 - vp1 + t0 + t0);

            if ADD_DEBUG then "ADD30"; end if;
            return 0,1,upp0,y1,vpp0,0; //n+np = 0
        end if;//dw

        //k := ExactQuotient(f - vp*(vp + h),up);
        t2 := vp1 + y1;
        t3 := vp0 + y0;
        k2 := t2 + t2;
        k1 := t3 + t3 - up1*k2;
        k0 := f2 - vp1^2 - up0*k2 - up1*k1;

        //s  := R!(Q!dw^-1)*k mod u;
        sp0 := (k0 - u0*(k1 - u0*k2));

        if IsZero(sp0) then
            if IsZero(t2) then
                
                if ADD_DEBUG then "ADD31"; end if;               
                return 0,0,1,y1,y0,2;
            end if;//t2

            w2   := t2^-1;
            upp0 := w2*t3 - up1 - u0; 
            vpp0 := upp0*t2 - vp0;

            if ADD_DEBUG then "ADD32"; end if;           
            return 0, 1, upp0, y1, vpp0, 1;
        end if;//sp0

        //s0 = sp0/d
        w2 := (sp0*dw)^-1;    //1/s*d^2
        w3 := w2*sp0;        //1/d
        w4 := dw^2*w2;       //1/s
        s0 := w3*sp0;

        //M1 := ExactQuotient(up*s-v+vp,u); M2:=ExactQuotient(s*(v+vp+h)-k,u); u:=-s*M1-M2;
        //upp  := ExactQuotient(-s*(s*up + 2*vp + h) + k, u);
        //upp  := upp/LeadingCoefficient(upp);
        t0  := s0*up1;
        upp1 := w4*t2 - s0/2 - u0;
        upp0 := w4*(t3 - t2*up1) - vp1 - t0/2 - u0*upp1;

        //vpp  := V - (V + s*up + vp + h) mod upp;
        vpp1 := upp1*s0 - t0 - vp1;
        vpp0 := s0*(upp0 - up0) - vp0;

        if ADD_DEBUG then "ADD33"; end if;
        return 1,upp1,upp0,vpp1,vpp0,0;
    end if;//d

    //k = k/2
    k2 := y1 + vp1;
    //k1 := y0 + vp0 - k2*up1;

    //sp0 := (v - vp) mod u;
    sp0 := v0 - vp0 - u0*(y1 - vp1 + t1 + t1);
    
    if IsZero(sp0) then  // s0 = 2*(up1 + u0)       
        if IsZero(k2) then //vp1 == -y1-h1, so (f - h*vn - vn^2) is deg 3
            
            if ADD_DEBUG then "ADD34"; end if;             
            return 0,0,1,y1,y0,2;
        end if;//k2

        w2 := k2^-1;
        upp0 := w2*(y0 + vp0) - up1 - u0; 
        vpp0 := upp0*k2 - vp0;

        if ADD_DEBUG then "ADD35"; end if;            
        return 0, 1, upp0, y1, vpp0, 1;
    end if;//sp0

    //s0 = sp0/d
    w2 := (sp0*d)^-1;    //1/s*d^2
    w3 := w2*sp0;        //1/d
    w4 := d^2*w2;       //1/s
    s0 := w3*sp0;

    //u  := ExactQuotient(s*(-s*u1 - 2*v1 - h) + k, u2);
    //u  := u/LeadingCoefficient(u);
    vh1  := s0*up1 + vp1;
    upp1 := w4*k2 - s0/2 - u0;
    upp0 := w4*(y0 + vp0 - k2*up1) - (vp1 + vh1)/2 - u0*upp1;

    //v := V + (-u1*s - v1 - h - V) mod u;
    vpp1 := upp1*s0 - vh1;
    vpp0 := s0*(upp0 - up0) - vp0;

    if ADD_DEBUG then "ADD36"; end if;
    return 1, upp1, upp0, vpp1, vpp0, 0;
end function;


///////////////////////////////////////////////////////////////////////////////
// Deg2ADD():         
// Input:     u0,v0: Mumford coordinates for divisor D=<x + u0,v0,0> in 
//                   reduced basis.
//  up0,up1,vp0,vp1: Mumford coordinates for divisor Dp=<x + up0,vp0,0> in 
//                   reduced basis.
//           ccs: Table of curve constants and precomputations, see 
//                Precompuation in nch23_splitG2_UTL.mag
//      
// Output: Mumford coordinates upp1,upp0,vpp1,vpp0 and balance weight npp for 
//         for reduceed and balanced Dpp ~ D + Dp.               
// Description: Explicit computation for adding a degree 2 and degree 2 divisor.                 
///////////////////////////////////////////////////////////////////////////////
Deg2ADD:= function(u0,u1,v0,v1,up0,up1,vp0,vp1,ccs)
    /* //startIGNORE
    //Poly Dev Testing
    FF:=Parent(u0);
    R<x>:=PolynomialRing(FF);
    f := R!ccs[1];
    h := R!ccs[2];
    V := R!ccs[3];
    u := x^2 + u1*x + u0;
    v := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + v1*x + v0;
    up := x^2 + up1*x + up0;
    vp := Coeff(V,3)*x^3 + Coeff(V,2)*x^2 + vp1*x + vp0;
    Q := quo<R | up>;
    
    //Formulation
    d := Resultant(u,up); // computed with 2x2 system
    if IsZero(d) then
        dw1 := u mod up; // = (a1^-1)*S for S,a1,b1 = XGCD(u,up);
        if IsZero(dw1) then //u = up
            dw2 := (vp+v+h) mod u;// = (b2^-1)*S for S,a2,b2 = XGCD(u,v + vp + h);
            if IsZero(dw2) then //vp = -v-h
                return 0,0,1,Coeff(V,1),Coeff(V,0),1;
            end if;
            k := ExactQuotient(f - v*(v + h),u);
            b2 := LeadingCoefficient(dw2)^-1;
            u := ExactQuotient(u,dw2*b2);
            s := b2*k mod u;
            upp := u^2;
            vpp := V - (V - v - u*s) mod upp;
            return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),0;
        end if;
        
        a1 := LeadingCoefficient(dw1)^-1;
        S1 := dw1*a1;
        
        dw3 := (vp+v+h) mod S1;// = (b2^-1)*S for S,a2,b2 = XGCD(S1,v + vp + h);
        if IsZero(dw3) then
            //S,a2,b2 := XGCD(S1,vp+v + h);
            //S1 = S, a2 = 1, b2 = 0;
            u := ExactQuotient(u,S1);
            up := ExactQuotient(up,S1);
            s  := a1*(vp - v) mod up;
            upp := u*up;
            vpp := V - (V - v - u*s) mod upp;
            return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),2 - Degree(upp);
        end if;

        k := ExactQuotient(f - v*(v + h),u);
        //S,a2,b2 := XGCD(S1,vp+v + h);
        //S := 1;
        b2 :=FF!dw3^-1;
        t := (1 - b2*(v + vp + h)) mod up;
        a2 := ExactQuotient(t,S1);
        s  := (a2*a1*(vp - v) + b2*k) mod up;           

        //M1 := ExactQuotient(u*s-v+v,up); M2:=ExactQuotient(s*(vp+v+h)-k,up); u:=-s*M1-M2;
        upp  := ExactQuotient(-s*(s*u + 2*v + h) + k, up);
        upp   := upp/LeadingCoefficient(upp);
        vpp   := V - (V + s*u + v + h) mod upp;
        if Degree(s) eq 1 and Degree(s*u + 2*v + h) lt 3 then
            npp := 2 - Degree(upp);
        else
            npp := 0;
        end if;
        
        return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),npp;

    end if;
    s := R!(Q!u^-1)*(vp-v) mod up;  //Using 2x2 system
    k := ExactQuotient(f - v*(v + h),u);
    //M1 := ExactQuotient(u*s-v+v,up); M2:=ExactQuotient(s*(vp+v+h)-k,up); u:=-s*M1-M2;
    upp  := ExactQuotient(-s*(s*u + 2*v + h) + k, up);
    upp   := upp/LeadingCoefficient(upp);
    vpp   := V - (V + s*u + v + h) mod upp;
    if Degree(s) eq 1 and Degree(s*u + 2*v + h) lt 3 then
        npp := 2 - Degree(upp);
    else
        npp := 0;
    end if;
    
    return Coeff(upp,2),Coeff(upp,1),Coeff(upp,0),Coeff(vpp,1),Coeff(vpp,0),npp;
    */ //endIGNORE
    
    f0:= ccs[1][1]; 
    f1:= ccs[1][2]; 
    f2:= ccs[1][3]; 
    f3:= ccs[1][4]; 
    f4:= ccs[1][5];  
    y0:= ccs[2][1]; 
    y1:= ccs[2][2];
    d1 := ccs[2][3];    
    
    //d := Resultant(u,up); // computed with 2x2 system
    m3 := up1 - u1;
    m4 := u0 - up0;
    m1 := m4 + up1*m3;
    m2 := -up0*m3;
    d  := m1*m4 - m2*m3;

    //Test for special case
    if IsZero(d) then
        //dw1 := u mod up; // = (a1^-1)*S for S,a1,b1 = XGCD(u,up); //dw1 := -m3x + m4;
        if IsZero(m3) then //u = up
            //dw2 := (vp+v+h) mod u;// = (b2^-1)*S for S,a2,b2 = XGCD(u,v + vp + h);
            t0 := u1 + u1;
            dw21:= vp1 + v1 - u0 - u0 + u1*t0;
            dw20:= vp0 + v0 + u0*t0;

            if IsZero(dw20) and IsZero(dw21) then //vp = -v-h
                
                if ADD_DEBUG then "ADD37"; end if;
                return 0,0,1,y1,y0,1;
            end if;//dw20dw21

            //k := ExactQuotient(f - v*(v + h),u);
            t2 := y1 - v1;
            t3 := y0 - v0;
            k2 := t2 + t2;
            k1 := t3 + t3 - u1*k2;
            k0 := f2 - v1^2 - u0*k2 - u1*k1;

            //b2 := LeadingCoefficient(dw2)^-1;
            b2 := dw21^-1;

            //u := ExactQuotient(u,dw2*b2);
            u0 := u1 - dw20*b2;

            //s := b2*k mod u;
            s0 := b2*(k0 - u0*(k1 - u0*k2));

            //upp := u^2;
            upp1 := u0 + u0;
            upp0 := u0^2;

            //vpp := V - (V - v - u*s) mod upp;
            vpp1 := s0 + v1;
            vpp0 := v0 + u0*s0;

            if ADD_DEBUG then "ADD38"; end if;
            return 1,upp1,upp0,vpp1,vpp0,0;
        end if;//m3

        //a1 := LeadingCoefficient(dw1)^-1; //a1 := (-m3)^-1;
        //S1 := dw1*a1;//S10 := m4*a1;//S1 := x + S10;
        //dw3 := (vp+v+h) mod S1;// = (b2^-1)*S for S,a2,b2 = XGCD(S1,v + vp + h);
        M2 := m3^2;
        M3 := -m3*M2;
        t0 := m4^2;
        t1 := vp1 + v1;
        dw3 := M3*(vp0 + v0) - m4*(M2*t1 + t0 + t0);
  
        if IsZero(dw3) then
            //S,a2,b2 := XGCD(S1,vp+v + h);
            //S1 = S, a2 = 1, b2 = 0;

            //a1 := LeadingCoefficient(dw1)^-1;
            //S1 := dw1*a1;
            a1 := -m3^-1;
            S1 := m4*a1;

            //u := ExactQuotient(u,S1);
            //up := ExactQuotient(up,S1);
            u0 := u1 - S1;             
            up0 := up1 - S1;

            //s  := a1*(vp - v) mod up;
            s0 := a1*(vp0 - v0 - up0*(vp1 - v1));

            //upp := u*up;
            upp1 := u0 + up0;
            upp0 := u0*up0;

            //vpp := V - (V - v - u*s) mod upp;
            vpp1 := v1 + s0;
            vpp0 := v0 + s0*u0;

            if ADD_DEBUG then "ADD39"; end if;
            return 1,upp1,upp0,vpp1,vpp0,0;
        end if;//dw3

        //k := ExactQuotient(f - v*(v + h),u);
        t2 := y1 - v1;
        t3 := y0 - v0;
        k2 := t2 + t2;
        k1 := t3 + t3 - u1*k2;
        k0 := f2 - v1^2 - u0*k2 - u1*k1;

        //S,a2,b2 := XGCD(S1,vp+v + h);S := 1;
        //T := (1 - b2*(v + vp + h)) mod up;
        //a2 := ExactQuotient(T,S1);
        //a12 := a1*a2;
        //a12 := M2*T1*(M2/dw3); with weight 1/M2
        t2 := up1^2 - up0;
        a12 := -M2*(t1 + t2 + t2);       
        
        //sp :=  (a12*(vp - v) + M3*k) mod up; s(dw3)
        sp1 := a12*(vp1 - v1) + M3*(k1 - up1*k2);
        sp0 := a12*(vp0 - v0) + M3*(k0 - up0*k2);
        D  := dw3^2;

        //Rest same as frequent case with d=dw3
        if IsZero(sp1) then
            if IsZero(sp0) then
                
                if ADD_DEBUG then "ADD40"; end if;
                return 0,0,1,y1,y0,0;
            end if;//sp0
        
            w2 := (dw3*sp0)^-1;
            s0 := sp0^2*w2;
            w3 := D*w2;
            
            t0:= s0*u1;
            upp0:= w3*((s0^2)/2 - y1 + v1) - up1;
            vpp0 := -v0 - s0*u0 + upp0*(t0 + y1 + v1 - upp0*(s0 - upp0 - upp0));

            if ADD_DEBUG then "ADD41"; end if;
            return 0, 1, upp0, y1, vpp0,0;
        end if;//sp1

        w1 := D - (sp1 + dw3)^2;
        
        if IsZero(w1) then  // Either s1 = 0 or s1 = -2
            // s1 = -2
            t1 := -u1 - u1;
            t2 := sp0 + dw3*t1;
            w0 := t2 + t2;
        
            if IsZero(w0) then
                
                if ADD_DEBUG then "ADD42"; end if;
                return 0,0,1,y1,y0,2;
            end if;//w0

            w2 := (dw3*w0)^-1;
            s0 := sp0*w0*w2;
            w3 := D*w2;
            
            t2:= s0*u1 - u0 - u0 + v1 + y1;
            t3:= s0 + t1;
            upp0:= w3*(t2 + t2 - s0*t3) - up1;
            vpp0:= upp0*(t2 - upp0*t3) - v0 - s0*u0;

            if ADD_DEBUG then "ADD43"; end if;
            return 0,1,upp0,y1,vpp0,1;
        end if;//w1

        w2 := (dw3*w1)^-1; //1/d^3*(s1*(s1 + 2))
        w3 := w2*w1;  //1/d
        w4 := w2*D*dw3; //1/(s1*(s1 + 2))
        s1 := sp1*w3;
        s0 := sp0*w3;
        
        l0   :=s0*u0;
        t1   :=s1*u1;
        l2   := s0 + t1;
        l1   := (s0 + s1)*(u0 + u1) - l0 - t1;
        upp1 := -w4*(s1*(l2 + s0) + s0 + s0) - up1;
        t0   := y1 - v1;
        t4   := l1 + v1;
        upp0 := w4*(t0 + t0 - s0*l2 - s1*(t4 + v1)) - up0 - up1*upp1;

        t0   := 2 + s1;
        t1   := upp1*t0;
        t2   := l2 - t1;
        t3   := upp0*t2;
        vpp1 := (upp0 + upp1)*(t0 + t2) - t4 - t1 - t3;
        vpp0 := t3 - v0 - l0;

        if ADD_DEBUG then "ADD44"; end if;
        return 1,upp1,upp0,vpp1,vpp0,0;
    end if;//d

    r0  := vp0 - v0;
    r1  := vp1 - v1;
    sp1 := r0*m3 + r1*m4;
    sp0 := r0*m1 + r1*m2;

    D  := d^2;
    if IsZero(sp1) then

        if IsZero(sp0) then

            if ADD_DEBUG then "ADD45"; end if;
            return 0,0,1,y1,y0,0;
        end if;//sp0
      
        w2 := (d*sp0)^-1;
        s0 := sp0^2*w2;
        w3 := D*w2;
        
        t0:= s0*u1;
        t1:= y1 - v1;
        upp0:= w3*((s0^2)/2 - t1) - up1;
        vpp0 := -v0 - s0*u0 + upp0*(t0 + y1 + v1 - upp0*(s0 - upp0 - upp0));

        if ADD_DEBUG then "ADD46"; end if;
        return 0, 1, upp0, y1, vpp0,0;
    end if;//sp1

    w1 := D - (sp1 + d)^2;
    
    if IsZero(w1) then  // Either s1 = 0 or s1 = -2
        // s1 = -2
        t1 := -u1 - u1;
        t2 := sp0 + d*t1;
        w0 := t2 + t2;
        
        if IsZero(w0) then

            if ADD_DEBUG then "ADD47"; end if;
            return 0,0,1,y1,y0,2;
        end if;//w0

        w2 := (d*w0)^-1;
        s0 := sp0*w0*w2;
        w3 := D*w2;
        
        t0:= s0*u1;
        t2:= t0 - u0 - u0 + v1 + y1;
        t3:= s0 + t1;
        upp0:= w3*(t2 + t2 - s0*t3) - up1;
        vpp0:= upp0*(t2 - upp0*t3) - v0 - s0*u0;

        if ADD_DEBUG then "ADD48"; end if;
        return 0,1,upp0,y1,vpp0,1;
    end if;//w1

    w2 := (d*w1)^-1; //1/d^3*(s1*(s1 + 2))
    w3 := w2*w1;  //1/d
    w4 := w2*D*d; //1/(s1*(s1 + 2))
    s1 := sp1*w3;
    s0 := sp0*w3;
    
    l0   :=s0*u0;
    t1   :=s1*u1;
    l2   := s0 + t1;
    l1   := (s0 + s1)*(u0 + u1) - l0 - t1;
    upp1 := -w4*(s1*(l2 + s0) + s0 + s0) - up1;
    t0   := y1 - v1;
    t4   := l1 + v1;
    upp0 := w4*(t0 + t0 - s0*l2 - s1*(t4 + v1)) - up0 - up1*upp1;

    t0   := 2 + s1;
    t1   := upp1*t0;
    t2   := l2 - t1;
    t3   := upp0*t2;
    vpp1 := (upp0 + upp1)*(t0 + t2) - t4 - t1 - t3;
    vpp0 := t3 - v0 - l0;

    if ADD_DEBUG then "ADD49"; end if;
    return 1,upp1,upp0,vpp1,vpp0,0;
end function;


///////////////////////////////////////////////////////////////////////////////
// ADD():
// Input: u1,v1,n1: Polynomials u,v and number n representing an arbirtrary
//                  divisor D1 over a split model HEC.
//        u2,v2,n2: Polynomials u,v and number n representing an arbirtrary
//                  divisor D2 over a split model HEC.
//             ccs: Table of curve constants and precomputations, see 
//                  Precompuation in splitG2UTL.mag.
//
// Output: Mumford coordinates upp2,upp1,upp0,vpp1,vpp0 for D1 + D2               
// Description: Explicit computation for adding any two divisors in reduced    
//              basis. Handles all cases explicitly.               
///////////////////////////////////////////////////////////////////////////////
ADD:= function(u1,v1,n1,u2,v2,n2,ccs)//startIGNORE
    u10:= Coeff(u1,0); u11:= Coeff(u1,1); u12:= Coeff(u1,2); 
    v10:= Coeff(v1,0); v11:= Coeff(v1,1);
    u20:= Coeff(u2,0); u21:= Coeff(u2,1); u22:= Coeff(u2,2); 
    v20:= Coeff(v2,0); v21:= Coeff(v2,1);
    n := n1 + n2 - 1;

    if IsOne(u12) then
        if IsOne(u22) then
            return Deg2ADD(u10,u11,v10,v11,u20,u21,v20,v21,ccs); //Deg2Add(0)

        elif IsOne(u21) then
            if IsZero(n2) then
                return Deg12ADDUP(u20,v20,u10,u11,v10,v11,ccs); //Deg12ADD with UP adjust
            else
                return Deg12ADD(u20,v20,u10,u11,v10,v11,ccs); //Deg12ADD with UP adjust
            end if;
        else
            if n2 eq 0 then
                return Deg02ADDUP(u10,u11,v10,v11,ccs); //Deg02ADD with UP Adjust
            elif n2 eq 1 then
            
                if ADD_DEBUG then "ADD50"; end if;
                return u12,u11,u10,v11,v10,0; //NEUTRAL
            else
                return Deg02ADDDWN(u10,u11,v10,v11,ccs); //Deg02ADD with DWN Adjust
            end if;
        end if;

    elif IsOne(u11) then
        if IsOne(u22) then
            if IsZero(n1) then
                return Deg12ADDUP(u10,v10,u20,u21,v20,v21,ccs); //Deg12ADD with UP adjust
            else
                return Deg12ADD(u10,v10,u20,u21,v20,v21,ccs); //Deg12ADD
            end if;


        elif IsOne(u21) then
            n := n1 + n2;
            if IsZero(n) then
                return Deg1ADDUP(u10,v10,u20,v20,ccs); //Deg1ADD with UP adjustment
            elif IsZero(n-2) then
                return Deg1ADDDWN(u10,v10,u20,v20,ccs); //Deg1ADD with DWN adjustment
            else
                return Deg1ADD(u10,v10,u20,v20,ccs); //Deg1ADD 
            end if;
        else
            if n2 eq 0 then
                if n1 eq 0 then
                    return Deg01ADDUP(u10,v10,ccs); //Deg01ADD with UP Adjust
                else
                    
                    if ADD_DEBUG then "ADD51"; end if;
                    return u12,u11,u10,v11,v10,0; 
                end if;
            elif n2 eq 1 then
                
                if ADD_DEBUG then "ADD52"; end if;
                return u12,u11,u10,v11,v10,n1; //NEUTRAL
            else
                if n1 eq 0 then
                    
                    if ADD_DEBUG then "ADD53"; end if;
                    return u12,u11,u10,v11,v10,1;
                else
                    return Deg01ADDDWN(u10,v10,ccs); //Deg01ADD with DWN Adjust
                end if;
            end if;
        end if;

    else 
        if IsOne(u22) then
            if n1 eq 0 then
                return Deg02ADDUP(u20,u21,v20,v21,ccs);//Deg02ADD with UP Adjust
            elif n1 eq 1 then

                if ADD_DEBUG then "ADD54"; end if;
                return u22,u21,u20,v21,v20,0; //NEUTRAL
            else
                return Deg02ADDDWN(u20,u21,v20,v21,ccs); //Deg02ADD with DWN Adjust
            end if;

        elif IsOne(u21) then
            if n1 eq 0 then
                if n2 eq 0 then
                    return Deg01ADDUP(u20,v20,ccs); //Deg01ADD with UP Adjust
                else

                    if ADD_DEBUG then "ADD55"; end if;
                    return u22,u21,u20,v21,v20,0; 
                end if;
            elif n1 eq 1 then
                
                if ADD_DEBUG then "ADD56"; end if;
                return u22,u21,u20,v21,v20,n2; //NEUTRAL
            else
                if n2 eq 0 then

                    if ADD_DEBUG then "ADD57"; end if;
                    return u22,u21,u20,v21,v20,1;
                else
                    return Deg01ADDDWN(u20,v20,ccs); //Deg01ADD with DWN Adjust
                end if;
            end if;

        else
            if ADD_DEBUG then "ADD58"; end if;
            return 0,0,1,ccs[2][2],ccs[2][1],n;
        end if;
    end if;
end function;//endIGNORE