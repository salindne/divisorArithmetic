///////////////////////////////////////////////////////////////////////////////
///////////// POLYNOMIAL DIVISOR ARITHMETIC OVER ARBIRTRARY FIELDS. ///////////
///////////////////////////////////////////////////////////////////////////////
//  
//
//-----------------------------------------------------------------------------
// OVERVIEW
//-----------------------------------------------------------------------------
// This file contains all arithmetic functions from poly_balanced_arithmetic 
// and poly_ram_arithemtic with out assertions for timing purposes.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////FUNCTIONS///////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Coeff(poly,n)
//-----------------------------------------------------------------------------
// Input: poly: Polynomial over a field.
//           n: natural number.
//
// Return: The n-monomial's coefficient.
//-----------------------------------------------------------------------------
Coeff := function(poly,n)
    c:=Coefficients(poly); return n+1 le #c select c[n+1] else 0;
end function;

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////RAMIFIED////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


//-----------------------------------------------------------------------------
// RandomCurve_RAM(g,q,hIsZero)
//-----------------------------------------------------------------------------
// Input:       g: genus.
//              q: field parameter.
//
// Return: Random(ish) hyperelliptic polynomials of curve with one point at
//         infinity f  in GF(q)[x] where f is seperable of degree 2g+1
//-----------------------------------------------------------------------------
RandomCurve_RAM := function(g,q)
    F:=GF(q);
    R<x>:=PolynomialRing(F);

    while true do
        //Randomly generate f for genus g
        f:= x^(2*g+1) + R ! [Random(F): i in [0..2*g]];

        //Check if f is hyperelliptic polynomials
        try
            C:=HyperellipticCurve(f);
            isHC:= true;

        catch e
            isHC:= false;
        end try;

        //If f is hyperelliptic polynomial, check to see if
        //the curve has one point at infinity and is genus g.
        if isHC then
            pointsAtInf:= PointsAtInfinity(C);
            if (# pointsAtInf eq 1) and (Degree(f) eq 2*g+1) then
                return f;
            end if;
        end if;
        
    end while;
end function;


//-----------------------------------------------------------------------------
// Add_RAM(D1,D2,f,g)
//-----------------------------------------------------------------------------
// Input: D1,D2: D1=(u1,v1,w1) and D2=(u2,v2,w2) reduced divisors over  
//               HyperellipticCurve(f).
//          f: hyperelliptic polynomial corresponding to curve that D1 and  
//               D2 are added over.
//            g: genus
// 
// Return: Unique reduced divisor D3 ~ D1 + D2 using specialized Cantor.
//-----------------------------------------------------------------------------
Add_RAM := function(D1,D2,f,g)
    u1 :=D1[1]; v1:=D1[2]; w1:=D1[3];
    u2 :=D2[1]; v2:=D2[2]; w2:=D2[3];

    S,a1,b1 := XGCD(u1,u2);
    K := a1*(v2 - v1) mod u2;
    if not IsOne(S) then
        S,a2,b2 := XGCD(S,v2 + v1);
        K  := (a2*K + b2*w1) mod u2;
        if not IsOne(S) then
            u1 := ExactQuotient(u1,S);
            u2 := ExactQuotient(u2,S);
            w1 :=  w1*S;
        end if;
    end if;
    T  := u1*K;
    u := u1*u2;
    v := v1 + T;
    w := ExactQuotient(w1 - K*(v1 + v),u2);

    //Normalize or Reduce
    if Degree(u) le g then
        if Degree(v) ge Degree(u) then
            q,r := Quotrem(v,u);
            w := w + q*(v + r);
            v := r;
        end if;
    else
        while Degree(u) gt g do
            tu := w;
            q,tv := Quotrem(-v,w);
            w := u + q*(tv - v);
            v := tv;
            u := tu; 
        end while;
        w := LeadingCoefficient(u)*w;
        u := u/LeadingCoefficient(u);
    end if;
    return <u,v,w>;
end function;


//-----------------------------------------------------------------------------
// Double_RAM(D,f,g)
//-----------------------------------------------------------------------------
// Input:     D: D=(u,v,w) reduced divisor over HyperellipticCurve(f).
//          f: hyperelliptic polynomials corresponding to curve that D is    
//               doubled over.
//            g: genus
// 
// Return: Unique reduced divisor Dp ~ D + D, (invokes Add function).
//-----------------------------------------------------------------------------
Double_RAM := function (D1,f,g) 
    u1 :=D1[1]; v1:=D1[2]; w1:=D1[3];

    //Compose
    t1 := v1 + v1;
    S,a1,b1 := XGCD(u1,t1);
    K  := b1*w1 mod u1;
    if not IsOne(S) then
        u1 := ExactQuotient(u1,S);
        w1 :=  w1*S;
    end if;
    T  := u1*K;
    u := u1^2;
    v := v1 + T;
    w := ExactQuotient(w1 - K*(t1 + T),u1);

    //Normalize or Reduce
    if Degree(u) le g then
        if Degree(v) ge Degree(u) then
            q,r := Quotrem(v,u);
            w := w + q*(v + r);
            v := r;
        end if;
    else
        while Degree(u) gt g do
            tu := w;
            q,tv := Quotrem(-v,w);
            w := u + q*(tv - v);
            v := tv;
            u := tu; 
        end while;
        w := LeadingCoefficient(u)*w;
        u := u/LeadingCoefficient(u);
    end if;
    return <u,v,w>;
end function;


//-----------------------------------------------------------------------------
// Nucomp_RAM(D1,D2,f,g)
//-----------------------------------------------------------------------------
// Input: D1,D2: D1=(u1,v1,w1) and D2=(u2,v2,w2) reduced divisors over  
//               HyperellipticCurve(f).
//          f: hyperelliptic polynomials corresponding to curve that D1 and  
//               D2 are added over.
//            g: genus
// 
// Return: Unique reduced divisor D3 ~ D1 + D2.
//-----------------------------------------------------------------------------
Nucomp_RAM := function(D1,D2,f,g)
    
    if Degree(D1[1]) lt Degree(D2[1]) then
        u2 := D1[1]; v2 := D1[2]; w2 := D1[3];
        u1 := D2[1]; v1 := D2[2]; w1 := D2[3];
    else
        u1 := D1[1]; v1 := D1[2]; w1 := D1[3];
        u2 := D2[1]; v2 := D2[2]; w2 := D2[3];
    end if;

    t2 := v2 - v1;
    S,a1,b1 := XGCD(u1,u2);
    K := a1*t2 mod u2;
    if not IsOne(S) then
        S,a2,b2 := XGCD(S,v2+v1);
        K  := (a2*K + b2*w1) mod u2;
        if not IsOne(S) then
            u1 := ExactQuotient(u1,S);
            u2 := ExactQuotient(u2,S);
            w1 :=  w1*S;
        end if;
    end if;

    if Degree(u2) + Degree(u1) le g then
        T  := u1*K;
        u := u1*u2;
        v := v1 + T;
        w := ExactQuotient(w1 - K*(v1 + v),u2);
        if Degree(v) ge Degree(u) then
            q,r := Quotrem(v,u);
            w := w + q*(v + r);
            v := r;
        end if;
    else
        rp := u2; r := K; cp := Parent(f)!0; c := Parent(f)!-1; l := -1;

        bound := (Degree(u2) - Degree(u1) + g)/2;
        while Degree(r) gt bound do
            q,rn := Quotrem(rp,r);
            rp := r; r := rn; cn := cp - q*c; cp := c; c := cn; l := -l;
        end while;
        t3 := u1*r;
        M1    := ExactQuotient(t3 + t2*c, u2);
        M2    := ExactQuotient(r*(v2 + v1) + w1*c, u2);
        u   := l*(r*M1 - c*M2);
        v   := (ExactQuotient(t3 + cp*u, c) - v1) mod u;
        u   := u/LeadingCoefficient(u);
        w   := ExactQuotient(f - v^2,u);
    end if;
    return <u,v,w>;
end function;


//-----------------------------------------------------------------------------
// Nuduple_RAM(D1,f,g)
//-----------------------------------------------------------------------------
// Input: D1: D1=(u1,v1,w1) reduced divisor over  
//               HyperellipticCurve(f).
//          f: hyperelliptic polynomials corresponding to curve that D1 is  
//               doubled over.
// 
// Return: Unique reduced divisor D3 ~ D1 + D2.
//-----------------------------------------------------------------------------
Nuduple_RAM := function(D1,f,g)
    u1 := D1[1]; v1 := D1[2]; w1 := D1[3];

    t2 := v1 + v1;
    S,a1,b1 := XGCD(u1,t2);
    K  := b1*w1 mod u1;
    if not IsOne(S) then
        u1 := ExactQuotient(u1,S);
        w1 :=  w1*S;
    end if;

    if 2*Degree(u1) le g then
        T  := u1*K;
        u := u1^2;
        v := v1 + T;
        w := ExactQuotient(w1 - K*(v1 + v),u1);
        if Degree(v) ge Degree(u) then
            q,r := Quotrem(v,u);
            w := w + q*(v + r);
            v := r;
        end if;
    else
        rp := u1; r := K; cp := Parent(f)!0; c := Parent(f)!-1; l := -1;

        bound := g/2;
        while Degree(r) gt bound do
            q,rn := Quotrem(rp,r);
            rp := r; r := rn; cn := cp - q*c; cp := c; c := cn; l := -l;
        end while;
        
        M2    := ExactQuotient(r*t2 + w1*c, u1);
        u   := l*(r^2 - c*M2);
        v   := (ExactQuotient(u1*r + cp*u, c) - v1) mod u;
        u   := u/LeadingCoefficient(u);
        w  := ExactQuotient(f - v^2,u);
    end if;
    return <u,v,w>;
end function;


//-----------------------------------------------------------------------------
// Neutral_RAM(f)
//-----------------------------------------------------------------------------
// Input: f: hyperelliptic polynomial corresponding to genus g curve that N     
//             is defined over.
//          
// Return: Unique neutral divisor N = <1,0>.
//-----------------------------------------------------------------------------
Neutral_RAM := function(f)
    return <Parent(f)!1,Parent(f)!0,f>;
end function;


//-----------------------------------------------------------------------------
// RandomDivisor_RAM(f,g)
//-----------------------------------------------------------------------------
// Input: f: hyperelliptic polynomials corresponding to curve that divisor is 
//             is being created for.
//
// Return: Fairly random divisor D = (u,v,w), over HyperellipticCurve(f).
//-----------------------------------------------------------------------------
RandomDivisor_RAM := function(f,g)
    FF := BaseRing(f);
    R<x> := Parent(f);  
    
    i := 0;
    rDivisor := Neutral_RAM(f);
    while i lt g do
        u := 0;
        while u eq 0 do
            u := R![Random(FF) : i in [1,2]];
        end while;
        u := u/LeadingCoefficient(u);

        //Check if degree 0 or 1
        if IsOne(u) then 
            i := i + 1;    
        else
            //Create quotient field with  u 
            S,projmap:=quo<R|u>;
            vChoices:= [a[1] : a in Factorization(x^2 - R!projmap(f))];

            //Make sure linear factorization exists
            //If not then retry
            if IsOne(Degree(vChoices[1])) then
                //Randomize choice of factor
                v := R!-Coeff(vChoices[Random([1,#vChoices])],0);
                w := ExactQuotient(f - v^2, u);
                rDivisor := Add_RAM(rDivisor,<u,v,w>,f,g);
                i := i + 1;    
            end if;
        end if;
    end while;
    return rDivisor;             
end function;






///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////SPLIT/////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


//-----------------------------------------------------------------------------
// RandomCurve_SPLIT(g,q,hIsZero)
//-----------------------------------------------------------------------------
// Input:       g: genus.
//              q: field parameter.
//
// Return: Random(ish) hyperelliptic polynomials of curve with two points at
//         infinity f  in GF(q)[x] where f is seperable of degree 2g+2 
//-----------------------------------------------------------------------------
RandomCurve_SPLIT := function(g,q)
    F:=GF(q);
    R<x>:=PolynomialRing(F);
    while true do
        //Randomly generate f  for genus g
        f:= x^(g*2 + 2) + R ! [Random(F): i in [0..2*g+1]];

        //Check if f is hyperelliptic polynomials
        try
            C:=HyperellipticCurve(f);
            isHC:= true;
        catch e
            isHC:= false;
        end try;

        //If f  is hyperelliptic polynomials, check to see if
        //the curve has two points at infinity and is genus g.
        if isHC then
            pointsAtInf:= PointsAtInfinity(C);
            if (# pointsAtInf eq 2) and (Degree(f) eq 2*g+2) then
                return f;
            end if;
        end if;
        
    end while;
end function;

//-----------------------------------------------------------------------------
// ComputeVpl(f)
//-----------------------------------------------------------------------------
// Input: f: hyperelliptic polynomial of a split curve.
//
// Return: Unique Vpl polynomial of degree g+1 for which 
//         deg(f-Vpl^2) <= g.
//-----------------------------------------------------------------------------
ComputeVpl := function(f,g)
    R<x>:=PolynomialRing(BaseRing(f));

    //Leading coefficient of f, has to have degree 2g+2
    fl:= Coeff(f,2*g+2);
    //Leading term of Vpl is set to be a solution of the quadratic equation fl - hl*x - x^2
    Vl:= -Coeff(Factorization(fl - x^2)[2][1],0);
    Vpl := Vl*x^(g+1);
    //Derivative of fl - hl*yl - yl^2, denominator in discovery of Vpl.
    dinv:= (2*Vl)^-1;
    //Work down one term at a time, using first g+1 terms of f
    i:=g;    
    while i ge 0 do
        Vpl +:= dinv*Coeff(f - Vpl^2, g+1+i)*x^i;
        i-:=1;
    end while;
    return Vpl;
end function;

//-----------------------------------------------------------------------------
// Neutral_SPLIT(f)
//-----------------------------------------------------------------------------
// Input: f: hyperelliptic polynomials corresponding to genus g curve that N     
//             is defined over.
//       V: V is unique polynomial of degree g+1 for which 
//            deg(f- V^2) <= g.
//          
// Return: Unique neutral divisor N = (1,0,f - V^2, Ceiling(g/2)).
//-----------------------------------------------------------------------------
Neutral_SPLIT := function(f,V)
    return <Parent(f)!1,V,f - V^2,Ceiling(ExactQuotient(Degree(f)-2,2)/2)>;
end function;

//-----------------------------------------------------------------------------
// Adjust_SPLIT_NEG(D,f,V,g)
//-----------------------------------------------------------------------------
// Input:  D: D=(u,v,w,n) semi-reduced divisor over HyperellipticCurve(f) with
//            deg(u) <= g+1.
//       f: hyperelliptic polynomials corresponding to curve that D is  
//            adjusted over.
//       V: -Vpl where Vpl is unique polynomial of degree g+1 for which 
//            deg(f -  Vpl^2) <= g.
//        g: genus
// 
// Return: Unique reduced divisor Dp = (up,vp,np) ~ D with deg(u) < g+1 and 
//         0 <= np <= deg(u)- g, using algorithm from Section 10.4 Galbraith 
//         book.
//-----------------------------------------------------------------------------
Adjust_SPLIT_NEG := function(D,f,V,g)
    u:=D[1]; v:=D[2]; w:= D[3]; n:=D[4];

    if (n lt 0) then
        //UP Adjust
        while (n lt 0) do
            //Adjustment
            ou := u; u := w;
            q,r := Quotrem(V + v,u);            
            tv  := V - r;
            w := ou - q*(tv - v);
            v := tv;
            n := n + g + 1 - Degree(u);
        end while;
        w := w*LeadingCoefficient(u);
        u := u/LeadingCoefficient(u);
    
    elif (n gt g-Degree(u)) then
        //DWN Adjust
        //Basis Conversion
        Vp := -V;
        t := Vp - V;        
        q,r := Quotrem(t,u);
        tv := v + t - r;
        w := w - q*(v + tv);
        v := tv;
        while (n gt g-Degree(u) + 1) do
            //Adjustment kept in positive reduced
            n := n + Degree(u)-(g+1);
            ou := u; u := w;
            q,r := Quotrem(Vp + v,u);            
            tv  := Vp - r;
            w := ou - q*(tv - v);
            v := tv;
        end while;
        if (n gt g-Degree(u)) then
            //Adjustment into negative reduced
            n := n + Degree(u)-(g+1);
            ou := u; u := w;
            q,r := Quotrem(V + v,u);            
            tv  := V - r;
            w := ou - q*(tv - v);
            v := tv;
        else
            t := V - Vp;        
            q,r := Quotrem(t,u);
            tv := v + t - r;
            w := w - q*(v + tv);
            v := tv;
        end if;

        w := w*LeadingCoefficient(u);
        u := u/LeadingCoefficient(u);
    end if;
    //If neither if clause is triggered, already adjusted.
    return <u,v,w,n>;    
    //end if;
end function;


//-----------------------------------------------------------------------------
// Add_SPLIT_NEG(D1,D2,f,Vp,V,g)
//-----------------------------------------------------------------------------
// Input: D1,D2: D1=(u1,v1,w1,n1) and D2=(u2,v2,w2,n2) reduced divisors over  
//               HyperellipticCurve(f).
//          f: hyperelliptic polynomials corresponding to curve that D1 and  
//               D2 are added over.
//           V: -Vpl  where Vpl is unique polynomial of degree g+1 for which 
//               deg(f - Vpl^2) <= g.
//            g: genus
// 
// Return: Unique reduced divisor D3 ~ D1 + D2.
//-----------------------------------------------------------------------------
Add_SPLIT_NEG := function(D1,D2,f,V,g)
    u1 :=D1[1]; v1:=D1[2]; w1:=D1[3]; n1:=D1[4];
    u2 :=D2[1]; v2:=D2[2]; w2:=D2[3]; n2:=D2[4];

    //Compose
    S,a1,b1 := XGCD(u1,u2);
    K := a1*(v2 - v1) mod u2;
    if not IsOne(S) then
        S,a2,b2 := XGCD(S,v2+v1);
        if not IsOne(S) then
            u1 := ExactQuotient(u1,S);
            u2 := ExactQuotient(u2,S);
            K  := (a2*K + b2*w1) mod u2;
            w1 := w1*S;
        else
            K  := (a2*K + b2*w1) mod u2;
        end if;
    end if;
    T  := u1*K;
    u := u1*u2;
    v := v1 + T;
    w := ExactQuotient(w1 - K*(v1 + v),u2);
    n := n1+n2+Degree(S)-Ceiling(g/2);
    
    //Normalize
    if Degree(v) ge Degree(u) then
            q,r := Quotrem(V - v,u);
            tv:= V - r;
            w  := w - q*(v + tv);
            v := tv;
    end if;

    //Reduce
    while Degree(u) gt g+1 do
        if Degree(v) eq g+1 and LeadingCoefficient(v) eq LeadingCoefficient(-V) then
            n := n + Degree(u) - (g + 1);
        elif Degree(v) eq g+1 and LeadingCoefficient(v) eq LeadingCoefficient(V) then
            n := n + g + 1 - Degree(w);
        else
            n:= n + (Degree(u) - Degree(w))/2;
        end if; 

        ou := u; u := w;
        q,r := Quotrem(V + v,u);            
        tv  := V - r;
        w := ou - q*(tv - v);
        v := tv;
    end while;

    w := w*LeadingCoefficient(u);
    u := u/LeadingCoefficient(u);
    return Adjust_SPLIT_NEG(<u,v,w,n>,f,V,g);
end function;


//-----------------------------------------------------------------------------
// Double_SPLIT_NEG(D,f,V,g)
//-----------------------------------------------------------------------------
// Input:     D: D=(u,v,w,n) reduced divisor over HyperellipticCurve(f).
//          f: hyperelliptic polynomials corresponding to curve that D is    
//               doubled over.
//           V: -Vpl  where Vpl is unique polynomial of degree g+1 for which 
//               deg(f - Vpl- Vpl^2) <= g.
//            g: genus
// 
// Return: Unique reduced divisor Dp ~ D + D, (invokes Add function).
//-----------------------------------------------------------------------------
Double_SPLIT_NEG := function (D1,f,V,g) 
    u1 :=D1[1]; v1:=D1[2]; w1:=D1[3]; n1:=D1[4];

    //Compose
    t1 := v1 + v1;
    S,a1,b1 := XGCD(u1,t1);
    
    if not IsOne(S) then
        u1 := ExactQuotient(u1,S);
        K  := b1*w1 mod u1;
        w1 :=  w1*S;
    else
        K  := b1*w1 mod u1;
    end if;

    T  := u1*K;
    u := u1^2;
    v := v1 + T;
    w := ExactQuotient(w1 - K*(t1 + T),u1);
    n := 2*n1 + Degree(S) - Ceiling(g/2);

    //Normalize
    if Degree(v) ge Degree(u) then
            q,r := Quotrem(V - v,u);
            tv:= V - r;
            w  := w - q*(v + tv);
            v := tv;
    end if;

    //Reduce
    while Degree(u) gt g+1 do
        if Degree(v) eq g+1 and LeadingCoefficient(v) eq LeadingCoefficient(-V) then
            n := n + Degree(u) - (g + 1);
        elif Degree(v) eq g+1 and LeadingCoefficient(v) eq LeadingCoefficient(V) then
            n := n + g + 1 - Degree(w);
        else
            n:= n + (Degree(u) - Degree(w))/2;
        end if; 

        ou := u; u := w;
        q,r := Quotrem(V + v,u);            
        tv  := V - r;
        w := ou - q*(tv - v);
        v := tv;
    end while;

    w := w*LeadingCoefficient(u);
    u := u/LeadingCoefficient(u);
    return Adjust_SPLIT_NEG(<u,v,w,n>,f,V,g);
end function;


//-----------------------------------------------------------------------------
// Nucomp_SPLIT_NEG(D1,D2,f,V,g)
//-----------------------------------------------------------------------------
// Input: D1,D2: D1=(u1,v1,w1,n1) and D2=(u2,v2,w2,n2) reduced divisors over  
//               HyperellipticCurve(f).
//          f: hyperelliptic polynomials corresponding to curve that D1 and  
//               D2 are added over.
//           V: -Vpl   where Vpl is unique polynomial of degree g+1 for which 
//               deg(f -  Vpl^2) <= g.
//            g: genus
// 
// Return: Unique reduced divisor D3 ~ D1 + D2.
//-----------------------------------------------------------------------------
Nucomp_SPLIT_NEG := function(D1,D2,f,V,g)
    if Degree(D1[1]) lt Degree(D2[1]) then
        u2 := D1[1]; v2 := D1[2]; w2 := D1[3]; n2 := D1[4];
        u1 := D2[1]; v1 := D2[2]; w1 := D2[3]; n1 := D2[4];
    else
        u1 := D1[1]; v1 := D1[2]; w1 := D1[3]; n1 := D2[4];
        u2 := D2[1]; v2 := D2[2]; w2 := D2[3]; n2 := D1[4];
    end if;


    t2 := v2 - v1;
    S,a1,b1 := XGCD(u1,u2);
    K := a1*(v2 - v1) mod u2;
    if not IsOne(S) then
        S,a2,b2 := XGCD(S,v2 + v1);
        if not IsOne(S) then
            u1 := ExactQuotient(u1,S);
            u2 := ExactQuotient(u2,S);
            K  := (a2*K + b2*w1) mod u2;
            w1 := w1*S;
        else
            K  := (a2*K + b2*w1) mod u2;
        end if;
    end if;
    deg := Degree(u2) + Degree(u1);
    n := n1 + n2 + Degree(S) - Ceiling(g/2);

    //No NUCOMP
    if deg le g  and ((n ge 0 and n le g-deg) or (Degree(w1) - Degree(u2) gt g)) then
        //Cantor Compose as is
        T  := u1*K;
        u := u1*u2;
        v := v1 + T;
        w := ExactQuotient(w1 - K*(v1 + v),u2);
        q,r := Quotrem(V - v,u);
        tv:= V - r;
        w  := w - q*(v + tv);
        v := tv;

    //NUCOMP
    else 
        r := K; rp := u2; cp:= Parent(f)!0; c:= Parent(f)!-1; l:= -1;

        //Reduction Portion of NUCOMP
        bound := (Degree(u2) - Degree(u1) + g + 1)/2;
        while Degree(r) ge bound do
            q,rn := Quotrem(rp,r);
            cn := cp - q*c; 
            rp := r; r := rn; cp := c; c := cn; l := -l;
        end while;

        //Reconsturct  divisor from continued fraction
        t3 := u1*r;
        M1  := ExactQuotient(t3 + t2*c, u2);
        M2  := ExactQuotient(r*(v2 + v1) + w1*c, u2);
        u := l*(r*M1 - c*M2);
        z := ExactQuotient(t3 + cp*u, c);
        v := V - ((v1 - z + V) mod u);
        u := u/LeadingCoefficient(u);
        w := ExactQuotient(f-v^2,u);

        //Check if last step was adjustment/special reduction.
        if Degree(z) lt g + 1 then
            //if LeadingCoefficient(v1) eq LeadingCoefficient(V) then                     
                n := n + Degree(u2) - Degree(rp) + g + 1 - Degree(u);
            //else                                
            //    nd := Degree(u1) + Degree(rp) - g - 1;
            //end if;
        else //No special reduction or adjust at end
            //if LeadingCoefficient(v1) eq LeadingCoefficient(V) then                 
                n := n + Degree(u2) - Degree(r);
            //else                          
            //    nd := Degree(u1) + Degree(r) - Degree(u);
            //end if;
        end if;

    end if;
    return Adjust_SPLIT_NEG(<u,v,w,n>,f,V,g); //Extra adjusts required if g ge 3
end function;


//-----------------------------------------------------------------------------
// Nuduple_SPLIT_NEG(D1,f,Vpl,g)
//-----------------------------------------------------------------------------
// Input: D1,D2: D1=(u1,v1,w1,n1) reduced divisor over  
//               HyperellipticCurve(f).
//          f: hyperelliptic polynomials corresponding to curve that D1 is  
//               doubleover.
//           V: -Vpl   where Vpl is unique polynomial of degree g+1 for which 
//               deg(f -  Vpl^2) <= g.
//            g: genus
// 
// Return: Unique reduced divisor D3 ~ D1 + D2.
//-----------------------------------------------------------------------------
Nuduple_SPLIT_NEG := function(D1,f,V,g)
    u1 := D1[1]; v1 := D1[2]; w1 := D1[3]; n1 := D1[4];

    t2 := v1 + v1;
    S,a1,b1 := XGCD(u1,t2);
    if not IsOne(S) then
        u1 := ExactQuotient(u1,S);
        K  := b1*w1 mod u1;
        w1 :=  w1*S;
    else
        K  := b1*w1 mod u1;
    end if;

    deg := 2*Degree(u1);
    n := 2*n1 + Degree(S) - Ceiling(g/2);

    //No NUCOMP
    if deg le g  and ((n ge 0 and n le g-deg) or (Degree(w1) - Degree(u1) gt g)) then
        //Cantor Compose as is
        T  := u1*K;
        u := u1^2;
        v := v1 + T;
        w := ExactQuotient(w1 - K*(t2 + T),u1);
        q,r := Quotrem(V - v,u);
        tv:= V - r;
        w  := w - q*(v + tv);
        v := tv;
        
    //NUCOMP
    else 
        //Composition Portion of NUCOMP        
        r:= K; rp := u1; cp:= Parent(f)!0; c:= Parent(f)!-1; l:= -1;

        //Reduction Portion of NUCOMP
        bound := (g + 1)/2;
        while Degree(r) ge bound do
            q,rn := Quotrem(rp,r);
            cn := cp - q*c; 
            rp := r; r := rn; cp := c; c := cn; l := -l;
            //c;
        end while;

        //Reconstruct divisor from continued fraction
        M2  := ExactQuotient(r*t2 + w1*c, u1);
        u := l*(r^2 - c*M2);
        z := ExactQuotient(u1*r + cp*u, c);
        v := V - ((v1 - z + V) mod u);
        u := u/LeadingCoefficient(u);
        w := ExactQuotient(f - v^2,u);
        //Check if last step was adjustment/special reduction.
        if Degree(z) lt g + 1 then
            //if LeadingCoefficient(v1) eq LeadingCoefficient(V) then                     
                nd := Degree(u1) - Degree(rp) + g + 1 - Degree(u);
            //else                                    
            //    nd := Degree(u1) + Degree(rp) - g - 1;
            //end if;
        else //No special reduction or adjust at end
            //if LeadingCoefficient(v1) eq LeadingCoefficient(V) then                 
                nd := Degree(u1) - Degree(r);
            //else             
            //    nd := Degree(u1) + Degree(r) - Degree(u);                  
            //end if;
        end if;
        n := n + nd;
    end if;
    return Adjust_SPLIT_NEG(<u,v,w,n>,f,V,g); //Extra adjusts required if g ge 3
end function;


//-----------------------------------------------------------------------------
// RandomDivisor_SPLIT(f,V,g)
//-----------------------------------------------------------------------------
// Input: f: hyperelliptic polynomials corresponding to curve that divisor is 
//             is being created for.
//         V: -Vpl  where Vpl is unique polynomial of degree g+1 for which 
//             deg(f - Vpl^2) <= g.
//          g: genus
//
// Return: Fairly random divisor D = (u,v,n), in negative or positive reduced 
//         basis over HyperellipticCurve(f).
//-----------------------------------------------------------------------------
RandomDivisor_SPLIT_NEG := function(f,V,g)
    FF := BaseRing(f);
    R<x> := Parent(f);  

    i := 0;
    rDivisor := Neutral_SPLIT(f,V);
    while i lt g  do
        u := R!0;
        while IsZero(u) do
            u := R![Random(FF) : i in [1,2]]; //..g+1]];
        end while;
        u := u/LeadingCoefficient(u);

        //Check if degree 0 or 1
        if IsOne(u) then 
            rDivisor := Add_SPLIT_NEG(rDivisor,<1,V,f - V^2,Random([0..g])>,f,V,g);
            i := i + 1;    
        else
            //Create quotient field with  u 
            S,projmap:=quo<R|u>;
            vChoices:= [a[1] : a in Factorization(x^2  - R!projmap(f))];

            //Make sure linear factorization exists
            //If not then retry
            if IsOne(Degree(vChoices[1])) then
                //Randomize choice of factor
                v := R!-Coeff(vChoices[Random([1,#vChoices])],0);
                v := v + V - (V mod u);
                w := ExactQuotient(f - v^2, u);
                rDivisor := Add_SPLIT_NEG(rDivisor,<u,v,w,Random([0..g-1])>,f,V,g);
                i := i + 1;    
            end if;
        end if;
    end while;
    return rDivisor;               

end function;


//POS



//-----------------------------------------------------------------------------
// Adjust_SPLIT_POS(D,f,V,g)
//-----------------------------------------------------------------------------
// Input:  D: D=(u,v,w,n) semi-reduced divisor over HyperellipticCurve(f) with
//            deg(u) <= g+1.
//       f: hyperelliptic polynomials corresponding to curve that D is  
//            adjusted over.
//       V: -Vpl   where Vpl is unique polynomial of degree g+1 for which 
//            deg(f - Vpl^2) <= g.
//        g: genus
// 
// Return: Unique reduced divisor Dp = (up,vp,np) ~ D with deg(u) < g+1 and 
//         0 <= np <= deg(u)- g, using algorithm from Section 10.4 Galbraith 
//         book.
//-----------------------------------------------------------------------------
Adjust_SPLIT_POS := function(D,f,V,g)
    u:=D[1]; v:=D[2]; w:= D[3]; n:=D[4];
   
    if (n gt g-Degree(u)) then
        //DWN Adjust
        while (n gt g-Degree(u)) do
            //Adjustment
            n := n + Degree(u)-(g+1);
            ou := u; u := w;
            q,r := Quotrem(V + v,u);            
            tv  := V - r;
            w := ou - q*(tv - v);
            v := tv;
        end while;
        w := w*LeadingCoefficient(u);
        u := u/LeadingCoefficient(u);

    elif (n lt 0) then
        //Basis Conversion to negative reduced
        Vp := -V;
        t := Vp - V;        
        q,r := Quotrem(t,u);
        tv := v + t - r;
        w := w - q*(v + tv);
        v := tv;
        while (n lt -1) do
            //Adjustment kept in negative reduced
            ou := u;  u := w;
            q,r := Quotrem(Vp + v,u);            
            tv  := Vp - r;
            w := ou - q*(tv - v);
            v := tv;
            n := n + g + 1 - Degree(u);
        end while;
        //UP Adjust back into positive reduced
        if n lt 0 then
            ou := u;  u := w;
            q,r := Quotrem(V + v,u);            
            tv  := V - r;
            w := ou - q*(tv - v);
            v := tv;
            n := n + g + 1 - Degree(u);
        else
            t := V - Vp;        
            q,r := Quotrem(t,u);
            tv := v + t - r;
            w := w - q*(v + tv);
            v := tv;
        end if;

        w := w*LeadingCoefficient(u);
        u := u/LeadingCoefficient(u);
    end if;
    //If neither if clause is triggered, already adjusted.
    return <u,v,w,n>;    
    //end if;
end function;

//-----------------------------------------------------------------------------
// Add_SPLIT_POS(D1,D2,f,Vp,V,g)
//-----------------------------------------------------------------------------
// Input: D1,D2: D1=(u1,v1,w1,n1) and D2=(u2,v2,w2,n2) reduced divisors over  
//               HyperellipticCurve(f).
//          f: hyperelliptic polynomials corresponding to curve that D1 and  
//               D2 are added over.
//           V: -Vpl   where Vpl is unique polynomial of degree g+1 for which 
//               deg(f - Vpl^2) <= g.
//            g: genus
// 
// Return: Unique reduced divisor D3 ~ D1 + D2.
//-----------------------------------------------------------------------------
Add_SPLIT_POS := function(D1,D2,f,V,g)
    u1 :=D1[1]; v1:=D1[2]; w1:=D1[3]; n1:=D1[4];
    u2 :=D2[1]; v2:=D2[2]; w2:=D2[3]; n2:=D2[4];

    //Compose
    S,a1,b1 := XGCD(u1,u2);
    K := a1*(v2 - v1) mod u2;
    if not IsOne(S) then
        S,a2,b2 := XGCD(S,v2+v1);
        if not IsOne(S) then
            u1 := ExactQuotient(u1,S);
            u2 := ExactQuotient(u2,S);
            K  := (a2*K + b2*w1) mod u2;
            w1 := w1*S;
        else
            K  := (a2*K + b2*w1) mod u2;
        end if;
    end if;
    T  := u1*K;
    u := u1*u2;
    v := v1 + T;
    w := ExactQuotient(w1 - K*(v1 + v),u2);
    n := n1+n2+Degree(S)-Ceiling(g/2);
    
    //Normalize
    if Degree(v) ge Degree(u) then
            q,r := Quotrem(V - v,u);
            tv:= V - r;
            w  := w - q*(v + tv);
            v := tv;
    end if;

    //Reduce
    while Degree(u) gt g+1 do
        if Degree(v) eq g+1 and LeadingCoefficient(v) eq LeadingCoefficient(V) then
            n := n + Degree(u) - (g + 1);
        elif Degree(v) eq g+1 and LeadingCoefficient(v) eq LeadingCoefficient(-V) then
            n := n + g + 1 - Degree(w);
        else
            n:= n + (Degree(u) - Degree(w))/2;
        end if; 

        ou := u; u := w;
        q,r := Quotrem(V + v,u);            
        tv  := V - r;
        w := ou - q*(tv - v);
        v := tv;
    end while;

    w := w*LeadingCoefficient(u);
    u := u/LeadingCoefficient(u);
    return Adjust_SPLIT_POS(<u,v,w,n>,f,V,g);
end function;


//-----------------------------------------------------------------------------
// Double_SPLIT_POS(D,f,V,g)
//-----------------------------------------------------------------------------
// Input:     D: D=(u,v,w,n) reduced divisor over HyperellipticCurve(f).
//          f: hyperelliptic polynomials corresponding to curve that D is    
//               doubled over.
//           V: -Vpl   where Vpl is unique polynomial of degree g+1 for which 
//               deg(f - Vpl^2) <= g.
//            g: genus
// 
// Return: Unique reduced divisor Dp ~ D + D, (invokes Add function).
//-----------------------------------------------------------------------------
Double_SPLIT_POS := function (D1,f,V,g) 
    u1 :=D1[1]; v1:=D1[2]; w1:=D1[3]; n1:=D1[4];

    //Compose
    t1 := v1 + v1;
    S,a1,b1 := XGCD(u1,t1);
    
    if not IsOne(S) then
        u1 := ExactQuotient(u1,S);
        K  := b1*w1 mod u1;
        w1 :=  w1*S;
    else
        K  := b1*w1 mod u1;
    end if;

    T  := u1*K;
    u := u1^2;
    v := v1 + T;
    w := ExactQuotient(w1 - K*(t1 + T),u1);
    n := 2*n1 + Degree(S) - Ceiling(g/2);

    //Normalize
    if Degree(v) ge Degree(u) then
            q,r := Quotrem(V - v,u);
            tv:= V - r;
            w  := w - q*(v  + tv);
            v := tv;
    end if;

    //Reduce
    while Degree(u) gt g+1 do
        if Degree(v) eq g+1 and LeadingCoefficient(v) eq LeadingCoefficient(V) then
            n := n + Degree(u) - (g + 1);
        elif Degree(v) eq g+1 and LeadingCoefficient(v) eq LeadingCoefficient(-V) then
            n := n + g + 1 - Degree(w);
        else
            n:= n + (Degree(u) - Degree(w))/2;
        end if; 

        ou := u; u := w;
        q,r := Quotrem(V + v,u);            
        tv  := V - r;
        w := ou - q*(tv - v);
        v := tv;
    end while;

    w := w*LeadingCoefficient(u);
    u := u/LeadingCoefficient(u);

    return Adjust_SPLIT_POS(<u,v,w,n>,f,V,g);
end function;


//-----------------------------------------------------------------------------
// Nucomp_SPLIT_POS(D1,D2,f,V,g)
//-----------------------------------------------------------------------------
// Input: D1,D2: D1=(u1,v1,w1,n1) and D2=(u2,v2,w2,n2) reduced divisors over  
//               HyperellipticCurve(f).
//          f: hyperelliptic polynomials corresponding to curve that D1 and  
//               D2 are added over.
//           V: -Vpl  where Vpl is unique polynomial of degree g+1 for which 
//               deg(f - Vpl^2) <= g.
//            g: genus
// 
// Return: Unique reduced divisor D3 ~ D1 + D2.
//-----------------------------------------------------------------------------
Nucomp_SPLIT_POS := function(D1,D2,f,V,g)
    if Degree(D1[1]) lt Degree(D2[1]) then
        u2 := D1[1]; v2 := D1[2]; w2 := D1[3]; n2 := D1[4];
        u1 := D2[1]; v1 := D2[2]; w1 := D2[3]; n1 := D2[4];
    else
        u1 := D1[1]; v1 := D1[2]; w1 := D1[3]; n1 := D2[4];
        u2 := D2[1]; v2 := D2[2]; w2 := D2[3]; n2 := D1[4];
    end if;

    t2 := v2 - v1;
    S,a1,b1 := XGCD(u1,u2);
    K := a1*(v2 - v1) mod u2;
    if not IsOne(S) then
        S,a2,b2 := XGCD(S,v2+v1);
        if not IsOne(S) then
            u1 := ExactQuotient(u1,S);
            u2 := ExactQuotient(u2,S);
            K  := (a2*K + b2*w1) mod u2;
            w1 := w1*S;
        else
            K  := (a2*K + b2*w1) mod u2;
        end if;
    end if;
    deg := Degree(u2) + Degree(u1);
    n := n1 + n2 + Degree(S) - Ceiling(g/2);

    //No NUCOMP
    if deg le g  and ((n ge 0 and n le g-deg) or (Degree(w1) - Degree(u2) gt g)) then
        //Cantor Compose as is
        T  := u1*K;
        u := u1*u2;
        v := v1 + T;
        w := ExactQuotient(w1 - K*(v1 + v),u2);
        q,r := Quotrem(V - v,u);
        tv:= V - r;
        w  := w - q*(v  + tv);
        v := tv;

    //NUCOMP
    else 
        r := K; rp := u2; cp:= Parent(f)!0; c:= Parent(f)!-1; l:= -1;

        //Reduction Portion of NUCOMP
        bound := (Degree(u2) - Degree(u1) + g + 2)/2;
        while Degree(r) ge bound do
            q,rn := Quotrem(rp,r);
            cn := cp - q*c; 
            rp := r; r := rn; cp := c; c := cn; l := -l;
        end while;

        //Reconsturct  divisor from continued fraction
        t3 := u1*r;
        M1  := ExactQuotient(t3 + t2*c, u2);
        M2  := ExactQuotient(r*(v2 + v1) + w1*c, u2);
        u := l*(r*M1 - c*M2);
        z := ExactQuotient(t3 + cp*u, c);
        v := V - ((v1 - z + V) mod u);
        u := u/LeadingCoefficient(u);
        w := ExactQuotient(f-v^2,u);

        //Check if last step was adjustment/special reduction.
        if Degree(z) lt g + 1 then
            //if LeadingCoefficient(v1) eq LeadingCoefficient(V) then                     
            //    n := n + Degree(u2) - Degree(rp) + g + 1 - Degree(u);
            //else                                
                n := n + Degree(u1) + Degree(rp) - g - 1;
            //end if;
        else //No special reduction or adjust at end
            //if LeadingCoefficient(v1) eq LeadingCoefficient(V) then                 
            //    n := n + Degree(u2) - Degree(r);
            //else                          
                n := n + Degree(u1) + Degree(r) - Degree(u);
            //end if;
        end if;
    end if;
    return Adjust_SPLIT_POS(<u,v,w,n>,f,V,g); //Extra adjusts required if g ge 3
end function;


//-----------------------------------------------------------------------------
// Nuduple_SPLIT_POS(D1,f,Vpl,g)
//-----------------------------------------------------------------------------
// Input: D1,D2: D1=(u1,v1,w1,n1) reduced divisor over  
//               HyperellipticCurve(f).
//          f: hyperelliptic polynomials corresponding to curve that D1 is  
//               doubleover.
//           V: -Vpl   where Vpl is unique polynomial of degree g+1 for which 
//               deg(f - Vpl^2) <= g.
//            g: genus
// 
// Return: Unique reduced divisor D3 ~ D1 + D2.
//-----------------------------------------------------------------------------
Nuduple_SPLIT_POS := function(D1,f,V,g)
    u1 := D1[1]; v1 := D1[2]; w1 := D1[3]; n1 := D1[4];
    
    t2 := v1 + v1;
    S,a1,b1 := XGCD(u1,t2);
    if not IsOne(S) then
        u1 := ExactQuotient(u1,S);
        K  := b1*w1 mod u1;
        w1 :=  w1*S;
    else
        K  := b1*w1 mod u1;
    end if;

    deg := 2*Degree(u1);
    n := 2*n1 + Degree(S) - Ceiling(g/2);

    //No NUCOMP
    if deg le g  and ((n ge 0 and n le g-deg) or (Degree(w1) - Degree(u1) gt g)) then
        //Cantor Compose as is
        T  := u1*K;
        u := u1^2;
        v := v1 + T;
        w := ExactQuotient(w1 - K*(t2 + T),u1);
        q,r := Quotrem(V - v,u);
        tv:= V - r;
        w  := w - q*(v + tv);
        v := tv;
        
    //NUCOMP
    else 
        //Composition Portion of NUCOMP        
        r:= K; rp := u1; cp:= Parent(f)!0; c:= Parent(f)!-1; l:= -1;

        //Reduction Portion of NUCOMP
        bound := (g + 1)/2;
        while Degree(r) ge bound do
            q,rn := Quotrem(rp,r);
            cn := cp - q*c; 
            rp := r; r := rn; cp := c; c := cn; l := -l;
            //c;
        end while;

        //Reconstruct divisor from continued fraction
        M2  := ExactQuotient(r*t2 + w1*c, u1);
        u := l*(r^2 - c*M2);
        z := ExactQuotient(u1*r + cp*u, c);
        v := V - ((v1 - z + V) mod u);
        u := u/LeadingCoefficient(u);
        w := ExactQuotient(f - v^2,u);
        //Check if last step was adjustment/special reduction.
        if Degree(r) + Degree(u1) - Degree(c) lt g + 1 then
            //if LeadingCoefficient(v1) eq LeadingCoefficient(V) then                     
            //    nd := Degree(u1) - Degree(rp) + g + 1 - Degree(u);
            //else                                    
                n := n + Degree(u1) + Degree(rp) - g - 1;
            //end if;
        else //No special reduction or adjust at end
            //if LeadingCoefficient(v1) eq LeadingCoefficient(V) then                 
            //    nd := Degree(u1) - Degree(r);
            //else             
                n := n + Degree(u1) + Degree(r) - Degree(u);                  
            //end if;
        end if;
    end if;
    return Adjust_SPLIT_POS(<u,v,w,n>,f,V,g); //Extra adjusts required if g ge 3
end function;


//-----------------------------------------------------------------------------
// RandomDivisor_SPLIT(f,V,g)
//-----------------------------------------------------------------------------
// Input: f: hyperelliptic polynomials corresponding to curve that divisor is 
//             is being created for.
//         V: -Vpl  where Vpl is unique polynomial of degree g+1 for which 
//             deg(f - Vpl^2) <= g.
//          g: genus
//
// Return: Fairly random divisor D = (u,v,n), in negative or positive reduced 
//         basis over HyperellipticCurve(f).
//-----------------------------------------------------------------------------
RandomDivisor_SPLIT_POS := function(f,V,g)
    FF := BaseRing(f);
    R<x> := Parent(f);  

    i := 0;
    rDivisor := Neutral_SPLIT(f,V);
    while i lt g do
        u := 0;
        while u eq 0 do
            u := R![Random(FF) : i in [1,2]]; //..g+1]];
        end while;
        u := u/LeadingCoefficient(u);

        //Check if degree 0 or 1
        if IsOne(u) then 
            rDivisor := Add_SPLIT_POS(rDivisor,<1,V,f - V^2,Random([0..g])>,f,V,g);
            i := i + 1;    
        else
            //Create quotient field with  u 
            S,projmap:=quo<R|u>;
            vChoices:= [a[1] : a in Factorization(x^2  - R!projmap(f))];

            //Make sure linear factorization exists
            //If not then retry
            if IsOne(Degree(vChoices[1])) then
                //Randomize choice of factor
                v := R!-Coeff(vChoices[Random([1,#vChoices])],0);
                v := v + V - (V mod u);
                w := ExactQuotient(f - v^2, u);
                rDivisor := Add_SPLIT_POS(rDivisor,<u,v,w,Random([0..g-1])>,f,V,g);
                i := i + 1;    
            end if;
        end if;
    end while;
    return rDivisor;               

end function;
